{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Roll Back Engine Documentation About Roll Back Engine is a 2D game engine made for an upcoming online fighting game. Use the left panel to navigate the documentation. Features Entity Component System Scene System Python scripting Networking system for online multiplayer Collision system","title":"Home"},{"location":"#welcome-to-roll-back-engine-documentation","text":"","title":"Welcome to Roll Back Engine Documentation"},{"location":"#about","text":"Roll Back Engine is a 2D game engine made for an upcoming online fighting game. Use the left panel to navigate the documentation.","title":"About"},{"location":"#features","text":"Entity Component System Scene System Python scripting Networking system for online multiplayer Collision system","title":"Features"},{"location":"general/core_concepts/","text":"Core Concepts Node Nodes are the basic building block of a game in Roll Back Engine. There are many different node types that inherit from the base Node class and more information about their API usage can be found here . Python scripts can be attached to Nodes to add to their functionality. Scene A scene is a collection of nodes. Must contain a root node and there can only be one root node per scene. Scenes can be instanced. When a scene is destroyed the root node as well as all it's children will also be removed. In Roll Back Engine all scenes are stored as json files. Here is an example of how a scene with just a root node is serialized to json. { \"name\": \"Main\", \"type\": \"Node\", \"tags\": [], \"external_scene_source\": \"\", \"components\": [ { \"transform2D\": { \"position\": { \"x\": 0.0, \"y\": 0.0 }, \"scale\": { \"x\": 0.0, \"y\": 0.0 }, \"rotation\": 0, \"z_index\": 0, \"z_index_relative_to_parent\": false, \"ignore_camera\": false } }, { \"scriptable_class\": { \"class_path\": \"assets.game_projects.fighter.src.init\", \"class_name\": \"Init\" } } ], \"children\": [] } Scene Tree The scene tree contains active scenes nodes. There are two types of active scenes. Main Scene The current main scene, there can only be one at a time. Singleton Scene Scenes that are made active when the game is initialized. They will stay active during the duration of the game unless queue_deletion() is called on them. Signal Signals can be used to apply the observer pattern to game logic. They are also used for notifying interested listeners about events for some of the systems within the engine (e.g. joystick disconnecting). Signals are defined within the base Node class. from roll.nodes import AnimatedSprite class Seika(AnimatedSprite): def _start(self) -> None: self.connect_signal(\"animation_finished\", self, \"_on_AnimatedSprite_animation_finished\") self.play(animation_name=\"swim\") def _on_AnimatedSprite_animation_finished(self, args : list) -> None: if self.animation.name == \"swim\": self.play(animation_name=\"idle\") Example to play an animation named 'idle' after the 'swim' animation is played.","title":"Core Concepts"},{"location":"general/core_concepts/#core-concepts","text":"","title":"Core Concepts"},{"location":"general/core_concepts/#node","text":"Nodes are the basic building block of a game in Roll Back Engine. There are many different node types that inherit from the base Node class and more information about their API usage can be found here . Python scripts can be attached to Nodes to add to their functionality.","title":"Node"},{"location":"general/core_concepts/#scene","text":"A scene is a collection of nodes. Must contain a root node and there can only be one root node per scene. Scenes can be instanced. When a scene is destroyed the root node as well as all it's children will also be removed. In Roll Back Engine all scenes are stored as json files. Here is an example of how a scene with just a root node is serialized to json. { \"name\": \"Main\", \"type\": \"Node\", \"tags\": [], \"external_scene_source\": \"\", \"components\": [ { \"transform2D\": { \"position\": { \"x\": 0.0, \"y\": 0.0 }, \"scale\": { \"x\": 0.0, \"y\": 0.0 }, \"rotation\": 0, \"z_index\": 0, \"z_index_relative_to_parent\": false, \"ignore_camera\": false } }, { \"scriptable_class\": { \"class_path\": \"assets.game_projects.fighter.src.init\", \"class_name\": \"Init\" } } ], \"children\": [] }","title":"Scene"},{"location":"general/core_concepts/#scene-tree","text":"The scene tree contains active scenes nodes. There are two types of active scenes. Main Scene The current main scene, there can only be one at a time. Singleton Scene Scenes that are made active when the game is initialized. They will stay active during the duration of the game unless queue_deletion() is called on them.","title":"Scene Tree"},{"location":"general/core_concepts/#signal","text":"Signals can be used to apply the observer pattern to game logic. They are also used for notifying interested listeners about events for some of the systems within the engine (e.g. joystick disconnecting). Signals are defined within the base Node class. from roll.nodes import AnimatedSprite class Seika(AnimatedSprite): def _start(self) -> None: self.connect_signal(\"animation_finished\", self, \"_on_AnimatedSprite_animation_finished\") self.play(animation_name=\"swim\") def _on_AnimatedSprite_animation_finished(self, args : list) -> None: if self.animation.name == \"swim\": self.play(animation_name=\"idle\") Example to play an animation named 'idle' after the 'swim' animation is played.","title":"Signal"},{"location":"general/project_properties/","text":"Project Properties Project properties define how the game will be configured before running. An example of the file is found below: Format { \"game_title\": \"Fighting Game Proto\", \"initial_scene\": \"scenes/init.json\", \"base_resolution\": { \"width\": 800, \"height\": 600 }, \"colliders_visible\": true, \"assets\": [ { \"type\": \"texture\", \"file_path\": \"assets/game_projects/fighter/assets/fighters/puncher/puncher_basic_sheet.png\" }, { \"type\": \"font\", \"file_path\": \"assets/fonts/bruh.ttf\", \"size\": 60 }, { \"type\": \"music\", \"file_path\": \"assets/audio/music/test_music.wav\" }, { \"type\": \"sound\", \"file_path\": \"assets/audio/sound/test_sound_effect.wav\" } ], \"input_actions\": [ { \"name\": \"quit\", \"values\": [\"esc\"] }, { \"name\": \"confirm\", \"values\": [\"return\"] } ] } Properties game_title Title of the game window. initial_scene First scene loaded for the game. base_resolution Base resolution of the game colliders_visible If true, will render a visible box for colliders. assets Textures, fonts, music, and sound effect assets are defined here. input_actions Key bindings are defined here.","title":"Project Properties"},{"location":"general/project_properties/#project-properties","text":"Project properties define how the game will be configured before running. An example of the file is found below:","title":"Project Properties"},{"location":"general/project_properties/#format","text":"{ \"game_title\": \"Fighting Game Proto\", \"initial_scene\": \"scenes/init.json\", \"base_resolution\": { \"width\": 800, \"height\": 600 }, \"colliders_visible\": true, \"assets\": [ { \"type\": \"texture\", \"file_path\": \"assets/game_projects/fighter/assets/fighters/puncher/puncher_basic_sheet.png\" }, { \"type\": \"font\", \"file_path\": \"assets/fonts/bruh.ttf\", \"size\": 60 }, { \"type\": \"music\", \"file_path\": \"assets/audio/music/test_music.wav\" }, { \"type\": \"sound\", \"file_path\": \"assets/audio/sound/test_sound_effect.wav\" } ], \"input_actions\": [ { \"name\": \"quit\", \"values\": [\"esc\"] }, { \"name\": \"confirm\", \"values\": [\"return\"] } ] }","title":"Format"},{"location":"general/project_properties/#properties","text":"game_title Title of the game window. initial_scene First scene loaded for the game. base_resolution Base resolution of the game colliders_visible If true, will render a visible box for colliders. assets Textures, fonts, music, and sound effect assets are defined here. input_actions Key bindings are defined here.","title":"Properties"},{"location":"python_api/","text":"Python API Contains information about the Python scripting API used for Roll Back Engine. Node Math Color Camera Audio Input Engine Physics Scene Network","title":"Index"},{"location":"python_api/#python-api","text":"Contains information about the Python scripting API used for Roll Back Engine. Node Math Color Camera Audio Input Engine Physics Scene Network","title":"Python API"},{"location":"python_api/audio/","text":"roll.audio Audio Interface for music and sound effects. Music will continue to loop until stopped and sound is only played once. Variables None. Signals None. Methods play_music(music_id: str) -> None: Plays music. stop_music() -> None: Stops currently playing music. set_music_volume(volume: int) -> None: Sets volume for music. play_sound(sound_id: str) -> None: Plays a sound. set_sounds_volume(volume: int) -> None: Sets volume for sounds. set_all_volume(volume: int) -> None: Sets volume for all audio.","title":"Audio"},{"location":"python_api/audio/#rollaudio","text":"","title":"roll.audio"},{"location":"python_api/audio/#audio","text":"Interface for music and sound effects. Music will continue to loop until stopped and sound is only played once.","title":"Audio"},{"location":"python_api/audio/#variables","text":"None.","title":"Variables"},{"location":"python_api/audio/#signals","text":"None.","title":"Signals"},{"location":"python_api/audio/#methods","text":"play_music(music_id: str) -> None: Plays music. stop_music() -> None: Stops currently playing music. set_music_volume(volume: int) -> None: Sets volume for music. play_sound(sound_id: str) -> None: Plays a sound. set_sounds_volume(volume: int) -> None: Sets volume for sounds. set_all_volume(volume: int) -> None: Sets volume for all audio.","title":"Methods"},{"location":"python_api/camera/","text":"roll.camera Camera Engine representation of a camera. Variables None. Signals None. Methods set_zoom(zoom: rool.math.Vector2) -> None: Sets the camera's zoom. get_zoom() -> rool.math.Vector2: Gets the camera's zoom. set_viewport_position(zoom: rool.math.Vector2) -> None: Sets the camera's viewport position. get_viewport_position() -> rool.math.Vector2: Gets the camera's viewport position.","title":"Camera"},{"location":"python_api/camera/#rollcamera","text":"","title":"roll.camera"},{"location":"python_api/camera/#camera","text":"Engine representation of a camera.","title":"Camera"},{"location":"python_api/camera/#variables","text":"None.","title":"Variables"},{"location":"python_api/camera/#signals","text":"None.","title":"Signals"},{"location":"python_api/camera/#methods","text":"set_zoom(zoom: rool.math.Vector2) -> None: Sets the camera's zoom. get_zoom() -> rool.math.Vector2: Gets the camera's zoom. set_viewport_position(zoom: rool.math.Vector2) -> None: Sets the camera's viewport position. get_viewport_position() -> rool.math.Vector2: Gets the camera's viewport position.","title":"Methods"},{"location":"python_api/color/","text":"roll.color Color Engine representation of color. Variables r : float Red color. g : float Green color. b : float Blue color. a : float Alpha or transparency of the color. Methods Static functions that return specific values WHITE() -> Color(1.0, 1.0, 1.0, 1.0): BLACK() -> Color(0.0, 0.0, 0.0, 1.0): RED() -> Color(1.0, 0.0, 0.0, 1.0): GREEN() -> Color(0.0, 1.0, 0.0, 1.0): BLUE() -> Color(0.0, 0.0, 1.0, 1.0):","title":"Color"},{"location":"python_api/color/#rollcolor","text":"","title":"roll.color"},{"location":"python_api/color/#color","text":"Engine representation of color.","title":"Color"},{"location":"python_api/color/#variables","text":"r : float Red color. g : float Green color. b : float Blue color. a : float Alpha or transparency of the color.","title":"Variables"},{"location":"python_api/color/#methods","text":"Static functions that return specific values WHITE() -> Color(1.0, 1.0, 1.0, 1.0): BLACK() -> Color(0.0, 0.0, 0.0, 1.0): RED() -> Color(1.0, 0.0, 0.0, 1.0): GREEN() -> Color(0.0, 1.0, 0.0, 1.0): BLUE() -> Color(0.0, 0.0, 1.0, 1.0):","title":"Methods"},{"location":"python_api/engine/","text":"roll.engine Engine Interface for miscellaneous operations for the game engine. Variables None. Signals None. Methods exit(code=0) -> None: Exits the engine returning the value of code as the exit code.","title":"Engine"},{"location":"python_api/engine/#rollengine","text":"","title":"roll.engine"},{"location":"python_api/engine/#engine","text":"Interface for miscellaneous operations for the game engine.","title":"Engine"},{"location":"python_api/engine/#variables","text":"None.","title":"Variables"},{"location":"python_api/engine/#signals","text":"None.","title":"Signals"},{"location":"python_api/engine/#methods","text":"exit(code=0) -> None: Exits the engine returning the value of code as the exit code.","title":"Methods"},{"location":"python_api/input/","text":"roll.input Input Class for handling input. Variables Mouse Action Values Mouse.LEFT_BUTTON = \"mb_left\" # Left Mouse Button Mouse.RIGHT_BUTTON = \"mb_right\" # Right Mouse Button Keyboard Action Values Keyboard.NUM_0 = 0 # Zero Keyboard.NUM_1 = 1 # One Keyboard.NUM_2 = 2 # Two Keyboard.NUM_3 = 3 # Three Keyboard.NUM_4 = 4 # Four Keyboard.NUM_5 = 5 # Five Keyboard.NUM_6 = 6 # Six Keyboard.NUM_7 = 7 # Seven Keyboard.NUM_8 = 8 # Eight Keyboard.NUM_9 = 9 # Nine Keyboard.A = \"a\" Keyboard.B = \"b\" Keyboard.C = \"c\" Keyboard.D = \"d\" Keyboard.E = \"e\" Keyboard.F = \"f\" Keyboard.G = \"g\" Keyboard.H = \"h\" Keyboard.I = \"i\" Keyboard.J = \"j\" Keyboard.K = \"k\" Keyboard.L = \"l\" Keyboard.M = \"m\" Keyboard.N = \"n\" Keyboard.O = \"o\" Keyboard.P = \"p\" Keyboard.Q = \"q\" Keyboard.R = \"r\" Keyboard.S = \"s\" Keyboard.T = \"t\" Keyboard.U = \"u\" Keyboard.V = \"v\" Keyboard.W = \"w\" Keyboard.X = \"x\" Keyboard.Y = \"y\" Keyboard.Z = \"z\" Keyboard.UP = \"up\" # Up Arrow Key Keyboard.DOWN = \"down\" # Down Arrow Key Keyboard.LEFT = \"left\" # Left Arrow Key Keyboard.RIGHT = \"right\" # Right Arrow Key Keyboard.SPACE = \"space\" # Space Key Keyboard.ESC = \"esc\" # ESC Key Keyboard.RETURN = \"return\" # Enter Key Keyboard.F1 = \"f1\" Keyboard.F2 = \"f2\" Keyboard.F3 = \"f3\" Keyboard.F4 = \"f4\" Keyboard.F5 = \"f5\" Keyboard.F6 = \"f6\" Keyboard.F7 = \"f7\" Keyboard.F8 = \"f8\" Keyboard.F9 = \"f9\" Keyboard.F10 = \"f10\" Keyboard.F11 = \"f11\" Keyboard.F12 = \"f12\" Joystick Action Values Joystick.A_BUTTON = \"joystick_button_a\" # XBOX A Joystick.B_BUTTON = \"joystick_button_b\" # XBOX B Joystick.X_BUTTON = \"joystick_button_x\" # XBOX X Joystick.Y_BUTTON = \"joystick_button_y\" # XBOX Y Joystick.KEYPAD_UP = \"joystick_keypad_up\" Joystick.KEYPAD_DOWN = \"joystick_keypad_down\" Joystick.KEYPAD_LEFT = \"joystick_keypad_left\" Joystick.KEYPAD_RIGHT = \"joystick_keypad_right\" Joystick.LEFT_ANALOG = \"joystick_left_analog\" Joystick.LEFT_ANALOG_LEFT = \"joystick_left_analog_left\" Joystick.LEFT_ANALOG_RIGHT = \"joystick_left_analog_right\" Joystick.LEFT_ANALOG_UP = \"joystick_left_analog_up\" Joystick.LEFT_ANALOG_DOWN = \"joystick_left_analog_down\" Joystick.RIGHT_ANALOG = \"joystick_right_analog\" Joystick.RIGHT_ANALOG_LEFT = \"joystick_right_analog_left\" Joystick.RIGHT_ANALOG_RIGHT = \"joystick_right_analog_right\" Joystick.RIGHT_ANALOG_UP = \"joystick_right_analog_up\" Joystick.RIGHT_ANALOG_DOWN = \"joystick_right_analog_down\" Joystick.START_BUTTON = \"joystick_start_button\" Joystick.BACK_BUTTON = \"joystick_back_button\" Joystick.SHOULDER_LEFT = \"joystick_left_shoulder\" Joystick.SHOULDER_RIGHT = \"joystick_right_shoulder\" Joystick.TRIGGER_LEFT = \"joystick_left_trigger\" Joystick.TRIGGER_RIGHT = \"joystick_right_trigger\" Signals None. Methods add_action(action_name: str, value: str) -> None: Adds an input action. Multiple input values can be added to the same action_name . See Variables for possible values. remove_action(action_name: str) -> None: Completely removes action. is_action_pressed(action_name: str) -> bool: Returns true if an action input is currently being held down. is_action_just_pressed(action_name: str) -> bool: Returns true if an action input was just pressed. is_action_just_released(action_name: str) -> bool: Returns true if an action input was just released.","title":"Input"},{"location":"python_api/input/#rollinput","text":"","title":"roll.input"},{"location":"python_api/input/#input","text":"Class for handling input.","title":"Input"},{"location":"python_api/input/#variables","text":"Mouse Action Values Mouse.LEFT_BUTTON = \"mb_left\" # Left Mouse Button Mouse.RIGHT_BUTTON = \"mb_right\" # Right Mouse Button Keyboard Action Values Keyboard.NUM_0 = 0 # Zero Keyboard.NUM_1 = 1 # One Keyboard.NUM_2 = 2 # Two Keyboard.NUM_3 = 3 # Three Keyboard.NUM_4 = 4 # Four Keyboard.NUM_5 = 5 # Five Keyboard.NUM_6 = 6 # Six Keyboard.NUM_7 = 7 # Seven Keyboard.NUM_8 = 8 # Eight Keyboard.NUM_9 = 9 # Nine Keyboard.A = \"a\" Keyboard.B = \"b\" Keyboard.C = \"c\" Keyboard.D = \"d\" Keyboard.E = \"e\" Keyboard.F = \"f\" Keyboard.G = \"g\" Keyboard.H = \"h\" Keyboard.I = \"i\" Keyboard.J = \"j\" Keyboard.K = \"k\" Keyboard.L = \"l\" Keyboard.M = \"m\" Keyboard.N = \"n\" Keyboard.O = \"o\" Keyboard.P = \"p\" Keyboard.Q = \"q\" Keyboard.R = \"r\" Keyboard.S = \"s\" Keyboard.T = \"t\" Keyboard.U = \"u\" Keyboard.V = \"v\" Keyboard.W = \"w\" Keyboard.X = \"x\" Keyboard.Y = \"y\" Keyboard.Z = \"z\" Keyboard.UP = \"up\" # Up Arrow Key Keyboard.DOWN = \"down\" # Down Arrow Key Keyboard.LEFT = \"left\" # Left Arrow Key Keyboard.RIGHT = \"right\" # Right Arrow Key Keyboard.SPACE = \"space\" # Space Key Keyboard.ESC = \"esc\" # ESC Key Keyboard.RETURN = \"return\" # Enter Key Keyboard.F1 = \"f1\" Keyboard.F2 = \"f2\" Keyboard.F3 = \"f3\" Keyboard.F4 = \"f4\" Keyboard.F5 = \"f5\" Keyboard.F6 = \"f6\" Keyboard.F7 = \"f7\" Keyboard.F8 = \"f8\" Keyboard.F9 = \"f9\" Keyboard.F10 = \"f10\" Keyboard.F11 = \"f11\" Keyboard.F12 = \"f12\" Joystick Action Values Joystick.A_BUTTON = \"joystick_button_a\" # XBOX A Joystick.B_BUTTON = \"joystick_button_b\" # XBOX B Joystick.X_BUTTON = \"joystick_button_x\" # XBOX X Joystick.Y_BUTTON = \"joystick_button_y\" # XBOX Y Joystick.KEYPAD_UP = \"joystick_keypad_up\" Joystick.KEYPAD_DOWN = \"joystick_keypad_down\" Joystick.KEYPAD_LEFT = \"joystick_keypad_left\" Joystick.KEYPAD_RIGHT = \"joystick_keypad_right\" Joystick.LEFT_ANALOG = \"joystick_left_analog\" Joystick.LEFT_ANALOG_LEFT = \"joystick_left_analog_left\" Joystick.LEFT_ANALOG_RIGHT = \"joystick_left_analog_right\" Joystick.LEFT_ANALOG_UP = \"joystick_left_analog_up\" Joystick.LEFT_ANALOG_DOWN = \"joystick_left_analog_down\" Joystick.RIGHT_ANALOG = \"joystick_right_analog\" Joystick.RIGHT_ANALOG_LEFT = \"joystick_right_analog_left\" Joystick.RIGHT_ANALOG_RIGHT = \"joystick_right_analog_right\" Joystick.RIGHT_ANALOG_UP = \"joystick_right_analog_up\" Joystick.RIGHT_ANALOG_DOWN = \"joystick_right_analog_down\" Joystick.START_BUTTON = \"joystick_start_button\" Joystick.BACK_BUTTON = \"joystick_back_button\" Joystick.SHOULDER_LEFT = \"joystick_left_shoulder\" Joystick.SHOULDER_RIGHT = \"joystick_right_shoulder\" Joystick.TRIGGER_LEFT = \"joystick_left_trigger\" Joystick.TRIGGER_RIGHT = \"joystick_right_trigger\"","title":"Variables"},{"location":"python_api/input/#signals","text":"None.","title":"Signals"},{"location":"python_api/input/#methods","text":"add_action(action_name: str, value: str) -> None: Adds an input action. Multiple input values can be added to the same action_name . See Variables for possible values. remove_action(action_name: str) -> None: Completely removes action. is_action_pressed(action_name: str) -> bool: Returns true if an action input is currently being held down. is_action_just_pressed(action_name: str) -> bool: Returns true if an action input was just pressed. is_action_just_released(action_name: str) -> bool: Returns true if an action input was just released.","title":"Methods"},{"location":"python_api/math/","text":"roll.math Vector2 Engine representation of a two-dimensional vector. Variables x : float X coordinate. y : float Y coordinate. Methods dot_product(value: roll.math.Vector2) -> float: Returns the dot product of two Vector2 items. Static functions that return specific values ZERO() -> Vector2(0.0, 0.0): LEFT() -> Vector2(-1.0, 0.0): RIGHT() -> Vector2(0.0, 1.0): UP() -> Vector2(0.0, -1.0): DOWN() -> Vector2(0.0, 1.0): Vector3 Engine representation of a two dimensional vector. Variables x : float X coordinate. y : float Y coordinate. z : float Z coordinate. Methods None. Rect2 Engine representation of a rectangle vector. Variables x : float X coordinate. y : float Y coordinate. w : float Rectangle's width. h : float Rectangle's height. Methods None.","title":"Math"},{"location":"python_api/math/#rollmath","text":"","title":"roll.math"},{"location":"python_api/math/#vector2","text":"Engine representation of a two-dimensional vector.","title":"Vector2"},{"location":"python_api/math/#variables","text":"x : float X coordinate. y : float Y coordinate.","title":"Variables"},{"location":"python_api/math/#methods","text":"dot_product(value: roll.math.Vector2) -> float: Returns the dot product of two Vector2 items. Static functions that return specific values ZERO() -> Vector2(0.0, 0.0): LEFT() -> Vector2(-1.0, 0.0): RIGHT() -> Vector2(0.0, 1.0): UP() -> Vector2(0.0, -1.0): DOWN() -> Vector2(0.0, 1.0):","title":"Methods"},{"location":"python_api/math/#vector3","text":"Engine representation of a two dimensional vector.","title":"Vector3"},{"location":"python_api/math/#variables_1","text":"x : float X coordinate. y : float Y coordinate. z : float Z coordinate.","title":"Variables"},{"location":"python_api/math/#methods_1","text":"None.","title":"Methods"},{"location":"python_api/math/#rect2","text":"Engine representation of a rectangle vector.","title":"Rect2"},{"location":"python_api/math/#variables_2","text":"x : float X coordinate. y : float Y coordinate. w : float Rectangle's width. h : float Rectangle's height.","title":"Variables"},{"location":"python_api/math/#methods_2","text":"None.","title":"Methods"},{"location":"python_api/network/","text":"roll.network Network Interface for network related operations for multiplayer. Variables None. Signals Server and Client signals. peer_connected Emitted once a peer is connected to the Server . peer_disconnected Emitted once a peer is disconnected from the Server . message_received Emitted once a message is received from the network. Client only signals. connected_to_server Emitted once a client successfully connects to a Server . connection_to_server_failed Emitted once a client fails to connect to a Server . Methods connect_signal(signal_id: str, listener_node: roll.node.Node, function_name: str) -> None: Connects to network related signal. Server Interface for server related operations for multiplayer. Variables None. Signals None. Methods start(port: int) -> None: Starts server on designated port . stop() -> None: Stops previously started server. send_message_to_all_clients(message: str) -> None: Sends message to all connected clients. Client Interface for client related operations for multiplayer. Variables None. Signals None. Methods connect(endpoint: str, port: int) -> None: Connects to a server with the passed in endpoint and port . disconnect() -> None: Disconnects from a server. send_message_to_server(message:str) -> None: Sends message to the server.","title":"Network"},{"location":"python_api/network/#rollnetwork","text":"","title":"roll.network"},{"location":"python_api/network/#network","text":"Interface for network related operations for multiplayer.","title":"Network"},{"location":"python_api/network/#variables","text":"None.","title":"Variables"},{"location":"python_api/network/#signals","text":"Server and Client signals. peer_connected Emitted once a peer is connected to the Server . peer_disconnected Emitted once a peer is disconnected from the Server . message_received Emitted once a message is received from the network. Client only signals. connected_to_server Emitted once a client successfully connects to a Server . connection_to_server_failed Emitted once a client fails to connect to a Server .","title":"Signals"},{"location":"python_api/network/#methods","text":"connect_signal(signal_id: str, listener_node: roll.node.Node, function_name: str) -> None: Connects to network related signal.","title":"Methods"},{"location":"python_api/network/#server","text":"Interface for server related operations for multiplayer.","title":"Server"},{"location":"python_api/network/#variables_1","text":"None.","title":"Variables"},{"location":"python_api/network/#signals_1","text":"None.","title":"Signals"},{"location":"python_api/network/#methods_1","text":"start(port: int) -> None: Starts server on designated port . stop() -> None: Stops previously started server. send_message_to_all_clients(message: str) -> None: Sends message to all connected clients.","title":"Methods"},{"location":"python_api/network/#client","text":"Interface for client related operations for multiplayer.","title":"Client"},{"location":"python_api/network/#variables_2","text":"None.","title":"Variables"},{"location":"python_api/network/#signals_2","text":"None.","title":"Signals"},{"location":"python_api/network/#methods_2","text":"connect(endpoint: str, port: int) -> None: Connects to a server with the passed in endpoint and port . disconnect() -> None: Disconnects from a server. send_message_to_server(message:str) -> None: Sends message to the server.","title":"Methods"},{"location":"python_api/node/","text":"roll.node Node Inherits : N/A. Class used as an interface for scene node functionality. Base class for all scene node types. Variables name : str Unique name of node once added to the scene. entity_id : int Unique id of entity. Signals None. Methods queue_deletion() -> None: Queues a node to be deleted and removed from a scene if it's currently added to the scene tree. add_child(node: Node) -> None: Adds a node as a child to the current node. get_node(name: str) -> roll.node.Node: Returns a node with the given name. Will be None if node is not found. create_signal(signal_id: str) -> None: Creates a signal for subscribers to listen to. connect_signal(signal_id: str, listener_node: roll.node.Node, function_name: str) -> None: Connects source node's signal to listener node. emit_signal(signal_id: str, args=[]) -> None: Emits signal from source node. _start() -> None: Called when entity is loaded into scene tree with all dependencies and children. _physics_process(delta_time: float) -> None: Called every frame. delta_time is passed in to have a frame consistent with CPU speed. _end() -> None: Called before entity exits scene tree. Node2D Inherits : Node Class used as an interface for scene 2D functionality. Base class for all 2D scene node types. Variables position : roll.math.Vector2 Current position of entity. Signals None. Methods get_position() -> roll.math.Vector2: Get node's current position. set_position(value: roll.math.Vector2) -> None: Set node's current position. add_to_position(value: roll.math.Vector2) -> None: Add to node's current position. For example, if this line of code is within the _process function, the output of this line of code node.add_to_position(Vector(5, 10)) within 3 frames will be [(5, 10), (10, 20), (15, 30)] . Sprite Inherits : Node2D -> Node Class used to render a sprite entity. Variables flip_h: bool Detemines whether the x axis is flipped. flip_v: bool Detemines whether the y axis is flipped. Signals None. Methods None. AnimatedSprite Inherits : Node2D -> Node Class used to render an animated sprite entity. Variables is_playing: bool Returns True if an animation is currently playing. flip_h: bool Detemines whether the x axis is flipped. flip_v: bool Detemines whether the y axis is flipped. Signals animation_finished Emitted when an animations is finished. frame_changed Emitted when an animation frame changes. Methods play(animation_name: str, start_frame = 0) -> None: Plays animation based on the name passed in. stop() -> None: Stops currently playing animation. TextLabel Inherits : Node2D -> Node Class used to render font. Variables text: str Text Label's text. color: roll.color.Color Color of the text. Signals None. Methods get_text() -> str: Get node's label text. set_text(value: str) -> None: Set node's label text. CollisionShape2D Inherits : Node2D -> Node Class used to define collision shapes defined as rectangles. May add other collision shapes in the future. Variables collider_rect: roll.math.Rect2 Collision shape's colliding rectangle. nodes_to_exclude: roll.color.Node Nodes that should be excluded from collision checks. Signals None. Methods None.","title":"Node"},{"location":"python_api/node/#rollnode","text":"","title":"roll.node"},{"location":"python_api/node/#node","text":"Inherits : N/A. Class used as an interface for scene node functionality. Base class for all scene node types.","title":"Node"},{"location":"python_api/node/#variables","text":"name : str Unique name of node once added to the scene. entity_id : int Unique id of entity.","title":"Variables"},{"location":"python_api/node/#signals","text":"None.","title":"Signals"},{"location":"python_api/node/#methods","text":"queue_deletion() -> None: Queues a node to be deleted and removed from a scene if it's currently added to the scene tree. add_child(node: Node) -> None: Adds a node as a child to the current node. get_node(name: str) -> roll.node.Node: Returns a node with the given name. Will be None if node is not found. create_signal(signal_id: str) -> None: Creates a signal for subscribers to listen to. connect_signal(signal_id: str, listener_node: roll.node.Node, function_name: str) -> None: Connects source node's signal to listener node. emit_signal(signal_id: str, args=[]) -> None: Emits signal from source node. _start() -> None: Called when entity is loaded into scene tree with all dependencies and children. _physics_process(delta_time: float) -> None: Called every frame. delta_time is passed in to have a frame consistent with CPU speed. _end() -> None: Called before entity exits scene tree.","title":"Methods"},{"location":"python_api/node/#node2d","text":"Inherits : Node Class used as an interface for scene 2D functionality. Base class for all 2D scene node types.","title":"Node2D"},{"location":"python_api/node/#variables_1","text":"position : roll.math.Vector2 Current position of entity.","title":"Variables"},{"location":"python_api/node/#signals_1","text":"None.","title":"Signals"},{"location":"python_api/node/#methods_1","text":"get_position() -> roll.math.Vector2: Get node's current position. set_position(value: roll.math.Vector2) -> None: Set node's current position. add_to_position(value: roll.math.Vector2) -> None: Add to node's current position. For example, if this line of code is within the _process function, the output of this line of code node.add_to_position(Vector(5, 10)) within 3 frames will be [(5, 10), (10, 20), (15, 30)] .","title":"Methods"},{"location":"python_api/node/#sprite","text":"Inherits : Node2D -> Node Class used to render a sprite entity.","title":"Sprite"},{"location":"python_api/node/#variables_2","text":"flip_h: bool Detemines whether the x axis is flipped. flip_v: bool Detemines whether the y axis is flipped.","title":"Variables"},{"location":"python_api/node/#signals_2","text":"None.","title":"Signals"},{"location":"python_api/node/#methods_2","text":"None.","title":"Methods"},{"location":"python_api/node/#animatedsprite","text":"Inherits : Node2D -> Node Class used to render an animated sprite entity.","title":"AnimatedSprite"},{"location":"python_api/node/#variables_3","text":"is_playing: bool Returns True if an animation is currently playing. flip_h: bool Detemines whether the x axis is flipped. flip_v: bool Detemines whether the y axis is flipped.","title":"Variables"},{"location":"python_api/node/#signals_3","text":"animation_finished Emitted when an animations is finished. frame_changed Emitted when an animation frame changes.","title":"Signals"},{"location":"python_api/node/#methods_3","text":"play(animation_name: str, start_frame = 0) -> None: Plays animation based on the name passed in. stop() -> None: Stops currently playing animation.","title":"Methods"},{"location":"python_api/node/#textlabel","text":"Inherits : Node2D -> Node Class used to render font.","title":"TextLabel"},{"location":"python_api/node/#variables_4","text":"text: str Text Label's text. color: roll.color.Color Color of the text.","title":"Variables"},{"location":"python_api/node/#signals_4","text":"None.","title":"Signals"},{"location":"python_api/node/#methods_4","text":"get_text() -> str: Get node's label text. set_text(value: str) -> None: Set node's label text.","title":"Methods"},{"location":"python_api/node/#collisionshape2d","text":"Inherits : Node2D -> Node Class used to define collision shapes defined as rectangles. May add other collision shapes in the future.","title":"CollisionShape2D"},{"location":"python_api/node/#variables_5","text":"collider_rect: roll.math.Rect2 Collision shape's colliding rectangle. nodes_to_exclude: roll.color.Node Nodes that should be excluded from collision checks.","title":"Variables"},{"location":"python_api/node/#signals_5","text":"None.","title":"Signals"},{"location":"python_api/node/#methods_5","text":"None.","title":"Methods"},{"location":"python_api/physics/","text":"roll.physics Collision Interface for collisions between entities. Variables None. Signals None. Methods get_collided_nodes(node: roll.node.Node) -> bool: Returns a list of nodes that collided with the passed in node .","title":"Physics"},{"location":"python_api/physics/#rollphysics","text":"","title":"roll.physics"},{"location":"python_api/physics/#collision","text":"Interface for collisions between entities.","title":"Collision"},{"location":"python_api/physics/#variables","text":"None.","title":"Variables"},{"location":"python_api/physics/#signals","text":"None.","title":"Signals"},{"location":"python_api/physics/#methods","text":"get_collided_nodes(node: roll.node.Node) -> bool: Returns a list of nodes that collided with the passed in node .","title":"Methods"},{"location":"python_api/scene/","text":"roll.scene Scene Tree Represents the scene tree which handles operations related to the scene system. Variables None. Signals None. Methods change_scene(scene_path: str) -> None: Change the scene to the current scene defined by scene_path . get_current_scene_node() -> roll.node.Node: Returns the root node of the current scene.","title":"Scene"},{"location":"python_api/scene/#rollscene","text":"","title":"roll.scene"},{"location":"python_api/scene/#scene-tree","text":"Represents the scene tree which handles operations related to the scene system.","title":"Scene Tree"},{"location":"python_api/scene/#variables","text":"None.","title":"Variables"},{"location":"python_api/scene/#signals","text":"None.","title":"Signals"},{"location":"python_api/scene/#methods","text":"change_scene(scene_path: str) -> None: Change the scene to the current scene defined by scene_path . get_current_scene_node() -> roll.node.Node: Returns the root node of the current scene.","title":"Methods"}]}