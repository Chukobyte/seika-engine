{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Seika Engine Documentation About Seika Engine is an open source 2D/3D game engine. Use the left panel to navigate the documentation. Features Entity Component System Scene System Python scripting Networking system for online multiplayer Collision system Keyboard, Mouse, and Joystick input management.","title":"Home"},{"location":"#welcome-to-seika-engine-documentation","text":"","title":"Welcome to Seika Engine Documentation"},{"location":"#about","text":"Seika Engine is an open source 2D/3D game engine. Use the left panel to navigate the documentation.","title":"About"},{"location":"#features","text":"Entity Component System Scene System Python scripting Networking system for online multiplayer Collision system Keyboard, Mouse, and Joystick input management.","title":"Features"},{"location":"general/command_line_flags/","text":"Command Line Flags Log Level -l -log-level [SEIKA_ENGINE] [LOG_LEVEL_FLAG] [LOG_LEVEL] Sets the log level of the engine to either DEBUG , WARN , INFO , ERROR .","title":"Command Line Flags"},{"location":"general/command_line_flags/#command-line-flags","text":"","title":"Command Line Flags"},{"location":"general/command_line_flags/#log-level","text":"-l -log-level [SEIKA_ENGINE] [LOG_LEVEL_FLAG] [LOG_LEVEL] Sets the log level of the engine to either DEBUG , WARN , INFO , ERROR .","title":"Log Level"},{"location":"general/core_concepts/","text":"Core Concepts Node Nodes are the basic building block of a game in Seika Engine. There are many different node types that inherit from the base Node class and more information about their API usage can be found here . Python scripts can be attached to Nodes to add to their functionality. Scene A scene is a collection of nodes. Must contain a root node and there can only be one root node per scene. Scenes can be instanced. When a scene is destroyed the root node as well as all it's children will also be removed. In Seika Engine all scenes are stored as json files. Here is an example of how a scene with just a root node is serialized to json. { \"name\": \"Main\", \"type\": \"Node\", \"tags\": [], \"external_scene_source\": \"\", \"components\": [ { \"transform2D\": { \"position\": { \"x\": 0.0, \"y\": 0.0 }, \"scale\": { \"x\": 0.0, \"y\": 0.0 }, \"rotation\": 0, \"z_index\": 0, \"z_index_relative_to_parent\": false, \"ignore_camera\": false } }, { \"scriptable_class\": { \"class_path\": \"assets.game_projects.fighter.src.init\", \"class_name\": \"Init\" } } ], \"children\": [] } Scene Tree The scene tree contains active scenes nodes. There are two types of active scenes. Main Scene The current main scene, there can only be one at a time. Singleton Scene Scenes that are made active when the game is initialized. They will stay active during the duration of the game unless queue_deletion() is called on them. Signal Signals can be used to apply the observer pattern to game logic. They are also used for notifying interested listeners about events for some of the systems within the engine (e.g. joystick disconnecting). Signals are defined within the base Node class. from seika.nodes import AnimatedSprite class Seika(AnimatedSprite): def _start(self) -> None: self.connect_signal(\"animation_finished\", self, \"_on_AnimatedSprite_animation_finished\") self.play(animation_name=\"swim\") def _on_AnimatedSprite_animation_finished(self, args : list) -> None: if self.animation.name == \"swim\": self.play(animation_name=\"idle\") Example to play an animation named 'idle' after the 'swim' animation is played.","title":"Core Concepts"},{"location":"general/core_concepts/#core-concepts","text":"","title":"Core Concepts"},{"location":"general/core_concepts/#node","text":"Nodes are the basic building block of a game in Seika Engine. There are many different node types that inherit from the base Node class and more information about their API usage can be found here . Python scripts can be attached to Nodes to add to their functionality.","title":"Node"},{"location":"general/core_concepts/#scene","text":"A scene is a collection of nodes. Must contain a root node and there can only be one root node per scene. Scenes can be instanced. When a scene is destroyed the root node as well as all it's children will also be removed. In Seika Engine all scenes are stored as json files. Here is an example of how a scene with just a root node is serialized to json. { \"name\": \"Main\", \"type\": \"Node\", \"tags\": [], \"external_scene_source\": \"\", \"components\": [ { \"transform2D\": { \"position\": { \"x\": 0.0, \"y\": 0.0 }, \"scale\": { \"x\": 0.0, \"y\": 0.0 }, \"rotation\": 0, \"z_index\": 0, \"z_index_relative_to_parent\": false, \"ignore_camera\": false } }, { \"scriptable_class\": { \"class_path\": \"assets.game_projects.fighter.src.init\", \"class_name\": \"Init\" } } ], \"children\": [] }","title":"Scene"},{"location":"general/core_concepts/#scene-tree","text":"The scene tree contains active scenes nodes. There are two types of active scenes. Main Scene The current main scene, there can only be one at a time. Singleton Scene Scenes that are made active when the game is initialized. They will stay active during the duration of the game unless queue_deletion() is called on them.","title":"Scene Tree"},{"location":"general/core_concepts/#signal","text":"Signals can be used to apply the observer pattern to game logic. They are also used for notifying interested listeners about events for some of the systems within the engine (e.g. joystick disconnecting). Signals are defined within the base Node class. from seika.nodes import AnimatedSprite class Seika(AnimatedSprite): def _start(self) -> None: self.connect_signal(\"animation_finished\", self, \"_on_AnimatedSprite_animation_finished\") self.play(animation_name=\"swim\") def _on_AnimatedSprite_animation_finished(self, args : list) -> None: if self.animation.name == \"swim\": self.play(animation_name=\"idle\") Example to play an animation named 'idle' after the 'swim' animation is played.","title":"Signal"},{"location":"general/project_properties/","text":"Project Properties Project properties define how the game will be configured before running. An example of the file is found below: Format { \"game_title\": \"Fighting Game Proto\", \"initial_scene\": \"scenes/init.json\", \"base_resolution\": { \"width\": 800, \"height\": 600 }, \"colliders_visible\": true, \"target_fps\": 60, \"background_color\": { \"red\": 0.1, \"green\": 0.1, \"blue\": 0.1 }, \"assets\": [ { \"type\": \"texture\", \"file_path\": \"assets/game_projects/fighter/assets/fighters/puncher/puncher_basic_sheet.png\" }, { \"type\": \"font\", \"file_path\": \"assets/fonts/bruh.ttf\", \"size\": 60 }, { \"type\": \"music\", \"file_path\": \"assets/audio/music/test_music.wav\" }, { \"type\": \"sound\", \"file_path\": \"assets/audio/sound/test_sound_effect.wav\" } ], \"input_actions\": [ { \"name\": \"quit\", \"values\": [\"esc\"] }, { \"name\": \"confirm\", \"values\": [\"return\"] } ] } Properties game_title Title of the game window. initial_scene First scene loaded for the game. base_resolution Base resolution of the game colliders_visible If true, will render a visible box for colliders. target_fps The FPS that the current game tries to achieve. background_color The background draw color of the renderer. assets Textures, fonts, music, and sound effect assets are defined here. input_actions Key bindings are defined here.","title":"Project Properties"},{"location":"general/project_properties/#project-properties","text":"Project properties define how the game will be configured before running. An example of the file is found below:","title":"Project Properties"},{"location":"general/project_properties/#format","text":"{ \"game_title\": \"Fighting Game Proto\", \"initial_scene\": \"scenes/init.json\", \"base_resolution\": { \"width\": 800, \"height\": 600 }, \"colliders_visible\": true, \"target_fps\": 60, \"background_color\": { \"red\": 0.1, \"green\": 0.1, \"blue\": 0.1 }, \"assets\": [ { \"type\": \"texture\", \"file_path\": \"assets/game_projects/fighter/assets/fighters/puncher/puncher_basic_sheet.png\" }, { \"type\": \"font\", \"file_path\": \"assets/fonts/bruh.ttf\", \"size\": 60 }, { \"type\": \"music\", \"file_path\": \"assets/audio/music/test_music.wav\" }, { \"type\": \"sound\", \"file_path\": \"assets/audio/sound/test_sound_effect.wav\" } ], \"input_actions\": [ { \"name\": \"quit\", \"values\": [\"esc\"] }, { \"name\": \"confirm\", \"values\": [\"return\"] } ] }","title":"Format"},{"location":"general/project_properties/#properties","text":"game_title Title of the game window. initial_scene First scene loaded for the game. base_resolution Base resolution of the game colliders_visible If true, will render a visible box for colliders. target_fps The FPS that the current game tries to achieve. background_color The background draw color of the renderer. assets Textures, fonts, music, and sound effect assets are defined here. input_actions Key bindings are defined here.","title":"Properties"},{"location":"python_api/","text":"Python API Contains information about the Python scripting API used for Seika Engine. Node Math Color Camera Audio Input Engine Physics Scene Network","title":"Index"},{"location":"python_api/#python-api","text":"Contains information about the Python scripting API used for Seika Engine. Node Math Color Camera Audio Input Engine Physics Scene Network","title":"Python API"},{"location":"python_api/audio/","text":"seika.audio Audio Interface for music and sound effects. Music will continue to loop until stopped and sound is only played once. Properties None. Signals None. Methods play_music(music_id: str) -> None: Plays music. stop_music() -> None: Stops currently playing music. set_music_volume(volume: int) -> None: Sets volume for music. play_sound(sound_id: str) -> None: Plays a sound. set_sounds_volume(volume: int) -> None: Sets volume for sounds. set_all_volume(volume: int) -> None: Sets volume for all audio.","title":"Audio"},{"location":"python_api/audio/#seikaaudio","text":"","title":"seika.audio"},{"location":"python_api/audio/#audio","text":"Interface for music and sound effects. Music will continue to loop until stopped and sound is only played once.","title":"Audio"},{"location":"python_api/audio/#properties","text":"None.","title":"Properties"},{"location":"python_api/audio/#signals","text":"None.","title":"Signals"},{"location":"python_api/audio/#methods","text":"play_music(music_id: str) -> None: Plays music. stop_music() -> None: Stops currently playing music. set_music_volume(volume: int) -> None: Sets volume for music. play_sound(sound_id: str) -> None: Plays a sound. set_sounds_volume(volume: int) -> None: Sets volume for sounds. set_all_volume(volume: int) -> None: Sets volume for all audio.","title":"Methods"},{"location":"python_api/camera/","text":"seika.camera Camera Engine representation of a camera. Properties None. Signals None. Methods set_zoom(zoom: seika.math.Vector2) -> None: Sets the camera's zoom. get_zoom() -> seika.math.Vector2: Gets the camera's zoom. set_viewport_position(zoom: seika.math.Vector2) -> None: Sets the camera's viewport position. get_viewport_position() -> seika.math.Vector2: Gets the camera's viewport position. set_offset(zoom: seika.math.Vector2) -> None: Sets the camera's offset. get_offset() -> seika.math.Vector2: Gets the camera's offset.","title":"Camera"},{"location":"python_api/camera/#seikacamera","text":"","title":"seika.camera"},{"location":"python_api/camera/#camera","text":"Engine representation of a camera.","title":"Camera"},{"location":"python_api/camera/#properties","text":"None.","title":"Properties"},{"location":"python_api/camera/#signals","text":"None.","title":"Signals"},{"location":"python_api/camera/#methods","text":"set_zoom(zoom: seika.math.Vector2) -> None: Sets the camera's zoom. get_zoom() -> seika.math.Vector2: Gets the camera's zoom. set_viewport_position(zoom: seika.math.Vector2) -> None: Sets the camera's viewport position. get_viewport_position() -> seika.math.Vector2: Gets the camera's viewport position. set_offset(zoom: seika.math.Vector2) -> None: Sets the camera's offset. get_offset() -> seika.math.Vector2: Gets the camera's offset.","title":"Methods"},{"location":"python_api/color/","text":"seika.color Color Engine representation of color. Properties r : float Red color. g : float Green color. b : float Blue color. a : float Alpha or transparency of the color. Methods Static functions that return specific values WHITE() -> Color(1.0, 1.0, 1.0, 1.0): BLACK() -> Color(0.0, 0.0, 0.0, 1.0): RED() -> Color(1.0, 0.0, 0.0, 1.0): GREEN() -> Color(0.0, 1.0, 0.0, 1.0): BLUE() -> Color(0.0, 0.0, 1.0, 1.0):","title":"Color"},{"location":"python_api/color/#seikacolor","text":"","title":"seika.color"},{"location":"python_api/color/#color","text":"Engine representation of color.","title":"Color"},{"location":"python_api/color/#properties","text":"r : float Red color. g : float Green color. b : float Blue color. a : float Alpha or transparency of the color.","title":"Properties"},{"location":"python_api/color/#methods","text":"Static functions that return specific values WHITE() -> Color(1.0, 1.0, 1.0, 1.0): BLACK() -> Color(0.0, 0.0, 0.0, 1.0): RED() -> Color(1.0, 0.0, 0.0, 1.0): GREEN() -> Color(0.0, 1.0, 0.0, 1.0): BLUE() -> Color(0.0, 0.0, 1.0, 1.0):","title":"Methods"},{"location":"python_api/engine/","text":"seika.engine Engine Interface for miscellaneous operations for the game engine. Properties None. Signals None. Methods exit(code=0) -> None: Exits the engine returning the value of code as the exit code. get_fps() -> float: Returns current FPS.","title":"Engine"},{"location":"python_api/engine/#seikaengine","text":"","title":"seika.engine"},{"location":"python_api/engine/#engine","text":"Interface for miscellaneous operations for the game engine.","title":"Engine"},{"location":"python_api/engine/#properties","text":"None.","title":"Properties"},{"location":"python_api/engine/#signals","text":"None.","title":"Signals"},{"location":"python_api/engine/#methods","text":"exit(code=0) -> None: Exits the engine returning the value of code as the exit code. get_fps() -> float: Returns current FPS.","title":"Methods"},{"location":"python_api/input/","text":"seika.input Input Class for handling input. Properties Mouse Action Values Mouse.LEFT_BUTTON = \"mb_left\" # Left Mouse Button Mouse.RIGHT_BUTTON = \"mb_right\" # Right Mouse Button Keyboard Action Values Keyboard.NUM_0 = 0 # Zero Keyboard.NUM_1 = 1 # One Keyboard.NUM_2 = 2 # Two Keyboard.NUM_3 = 3 # Three Keyboard.NUM_4 = 4 # Four Keyboard.NUM_5 = 5 # Five Keyboard.NUM_6 = 6 # Six Keyboard.NUM_7 = 7 # Seven Keyboard.NUM_8 = 8 # Eight Keyboard.NUM_9 = 9 # Nine Keyboard.A = \"a\" Keyboard.B = \"b\" Keyboard.C = \"c\" Keyboard.D = \"d\" Keyboard.E = \"e\" Keyboard.F = \"f\" Keyboard.G = \"g\" Keyboard.H = \"h\" Keyboard.I = \"i\" Keyboard.J = \"j\" Keyboard.K = \"k\" Keyboard.L = \"l\" Keyboard.M = \"m\" Keyboard.N = \"n\" Keyboard.O = \"o\" Keyboard.P = \"p\" Keyboard.Q = \"q\" Keyboard.R = \"r\" Keyboard.S = \"s\" Keyboard.T = \"t\" Keyboard.U = \"u\" Keyboard.V = \"v\" Keyboard.W = \"w\" Keyboard.X = \"x\" Keyboard.Y = \"y\" Keyboard.Z = \"z\" Keyboard.UP = \"up\" # Up Arrow Key Keyboard.DOWN = \"down\" # Down Arrow Key Keyboard.LEFT = \"left\" # Left Arrow Key Keyboard.RIGHT = \"right\" # Right Arrow Key Keyboard.SPACE = \"space\" # Space Key Keyboard.ESC = \"esc\" # ESC Key Keyboard.RETURN = \"return\" # Enter Key Keyboard.F1 = \"f1\" Keyboard.F2 = \"f2\" Keyboard.F3 = \"f3\" Keyboard.F4 = \"f4\" Keyboard.F5 = \"f5\" Keyboard.F6 = \"f6\" Keyboard.F7 = \"f7\" Keyboard.F8 = \"f8\" Keyboard.F9 = \"f9\" Keyboard.F10 = \"f10\" Keyboard.F11 = \"f11\" Keyboard.F12 = \"f12\" Joystick Action Values Joystick.A_BUTTON = \"joystick_button_a\" # XBOX A Joystick.B_BUTTON = \"joystick_button_b\" # XBOX B Joystick.X_BUTTON = \"joystick_button_x\" # XBOX X Joystick.Y_BUTTON = \"joystick_button_y\" # XBOX Y Joystick.KEYPAD_UP = \"joystick_keypad_up\" Joystick.KEYPAD_DOWN = \"joystick_keypad_down\" Joystick.KEYPAD_LEFT = \"joystick_keypad_left\" Joystick.KEYPAD_RIGHT = \"joystick_keypad_right\" Joystick.LEFT_ANALOG = \"joystick_left_analog\" Joystick.LEFT_ANALOG_LEFT = \"joystick_left_analog_left\" Joystick.LEFT_ANALOG_RIGHT = \"joystick_left_analog_right\" Joystick.LEFT_ANALOG_UP = \"joystick_left_analog_up\" Joystick.LEFT_ANALOG_DOWN = \"joystick_left_analog_down\" Joystick.RIGHT_ANALOG = \"joystick_right_analog\" Joystick.RIGHT_ANALOG_LEFT = \"joystick_right_analog_left\" Joystick.RIGHT_ANALOG_RIGHT = \"joystick_right_analog_right\" Joystick.RIGHT_ANALOG_UP = \"joystick_right_analog_up\" Joystick.RIGHT_ANALOG_DOWN = \"joystick_right_analog_down\" Joystick.START_BUTTON = \"joystick_button_start\" Joystick.BACK_BUTTON = \"joystick_button_start\" Joystick.SHOULDER_LEFT = \"joystick_left_shoulder\" Joystick.SHOULDER_RIGHT = \"joystick_right_shoulder\" Joystick.TRIGGER_LEFT = \"joystick_left_trigger\" Joystick.TRIGGER_RIGHT = \"joystick_right_trigger\" Signals None. Methods add_action(action_name: str, value: str) -> None: Adds an input action. Multiple input values can be added to the same action_name . See Properties for possible values. remove_action(action_name: str) -> None: Completely removes action. is_action_pressed(action_name: str) -> bool: Returns true if an action input is currently being held down. is_action_just_pressed(action_name: str) -> bool: Returns true if an action input was just pressed. is_action_just_released(action_name: str) -> bool: Returns true if an action input was just released.","title":"Input"},{"location":"python_api/input/#seikainput","text":"","title":"seika.input"},{"location":"python_api/input/#input","text":"Class for handling input.","title":"Input"},{"location":"python_api/input/#properties","text":"Mouse Action Values Mouse.LEFT_BUTTON = \"mb_left\" # Left Mouse Button Mouse.RIGHT_BUTTON = \"mb_right\" # Right Mouse Button Keyboard Action Values Keyboard.NUM_0 = 0 # Zero Keyboard.NUM_1 = 1 # One Keyboard.NUM_2 = 2 # Two Keyboard.NUM_3 = 3 # Three Keyboard.NUM_4 = 4 # Four Keyboard.NUM_5 = 5 # Five Keyboard.NUM_6 = 6 # Six Keyboard.NUM_7 = 7 # Seven Keyboard.NUM_8 = 8 # Eight Keyboard.NUM_9 = 9 # Nine Keyboard.A = \"a\" Keyboard.B = \"b\" Keyboard.C = \"c\" Keyboard.D = \"d\" Keyboard.E = \"e\" Keyboard.F = \"f\" Keyboard.G = \"g\" Keyboard.H = \"h\" Keyboard.I = \"i\" Keyboard.J = \"j\" Keyboard.K = \"k\" Keyboard.L = \"l\" Keyboard.M = \"m\" Keyboard.N = \"n\" Keyboard.O = \"o\" Keyboard.P = \"p\" Keyboard.Q = \"q\" Keyboard.R = \"r\" Keyboard.S = \"s\" Keyboard.T = \"t\" Keyboard.U = \"u\" Keyboard.V = \"v\" Keyboard.W = \"w\" Keyboard.X = \"x\" Keyboard.Y = \"y\" Keyboard.Z = \"z\" Keyboard.UP = \"up\" # Up Arrow Key Keyboard.DOWN = \"down\" # Down Arrow Key Keyboard.LEFT = \"left\" # Left Arrow Key Keyboard.RIGHT = \"right\" # Right Arrow Key Keyboard.SPACE = \"space\" # Space Key Keyboard.ESC = \"esc\" # ESC Key Keyboard.RETURN = \"return\" # Enter Key Keyboard.F1 = \"f1\" Keyboard.F2 = \"f2\" Keyboard.F3 = \"f3\" Keyboard.F4 = \"f4\" Keyboard.F5 = \"f5\" Keyboard.F6 = \"f6\" Keyboard.F7 = \"f7\" Keyboard.F8 = \"f8\" Keyboard.F9 = \"f9\" Keyboard.F10 = \"f10\" Keyboard.F11 = \"f11\" Keyboard.F12 = \"f12\" Joystick Action Values Joystick.A_BUTTON = \"joystick_button_a\" # XBOX A Joystick.B_BUTTON = \"joystick_button_b\" # XBOX B Joystick.X_BUTTON = \"joystick_button_x\" # XBOX X Joystick.Y_BUTTON = \"joystick_button_y\" # XBOX Y Joystick.KEYPAD_UP = \"joystick_keypad_up\" Joystick.KEYPAD_DOWN = \"joystick_keypad_down\" Joystick.KEYPAD_LEFT = \"joystick_keypad_left\" Joystick.KEYPAD_RIGHT = \"joystick_keypad_right\" Joystick.LEFT_ANALOG = \"joystick_left_analog\" Joystick.LEFT_ANALOG_LEFT = \"joystick_left_analog_left\" Joystick.LEFT_ANALOG_RIGHT = \"joystick_left_analog_right\" Joystick.LEFT_ANALOG_UP = \"joystick_left_analog_up\" Joystick.LEFT_ANALOG_DOWN = \"joystick_left_analog_down\" Joystick.RIGHT_ANALOG = \"joystick_right_analog\" Joystick.RIGHT_ANALOG_LEFT = \"joystick_right_analog_left\" Joystick.RIGHT_ANALOG_RIGHT = \"joystick_right_analog_right\" Joystick.RIGHT_ANALOG_UP = \"joystick_right_analog_up\" Joystick.RIGHT_ANALOG_DOWN = \"joystick_right_analog_down\" Joystick.START_BUTTON = \"joystick_button_start\" Joystick.BACK_BUTTON = \"joystick_button_start\" Joystick.SHOULDER_LEFT = \"joystick_left_shoulder\" Joystick.SHOULDER_RIGHT = \"joystick_right_shoulder\" Joystick.TRIGGER_LEFT = \"joystick_left_trigger\" Joystick.TRIGGER_RIGHT = \"joystick_right_trigger\"","title":"Properties"},{"location":"python_api/input/#signals","text":"None.","title":"Signals"},{"location":"python_api/input/#methods","text":"add_action(action_name: str, value: str) -> None: Adds an input action. Multiple input values can be added to the same action_name . See Properties for possible values. remove_action(action_name: str) -> None: Completely removes action. is_action_pressed(action_name: str) -> bool: Returns true if an action input is currently being held down. is_action_just_pressed(action_name: str) -> bool: Returns true if an action input was just pressed. is_action_just_released(action_name: str) -> bool: Returns true if an action input was just released.","title":"Methods"},{"location":"python_api/math/","text":"seika.math Math Generic math functions Properties None. Signals None. Methods lerp(source: float, destination: float, amount: float) -> float: Linearly interpolate between two values. Vector2 Engine representation of a two-dimensional vector. Properties x : float X coordinate. y : float Y coordinate. Signals None. Methods dot_product(value: seika.math.Vector2) -> float: Returns the dot product of two Vector2 items. lerp(source: seika.math.Vector2, destination: seika.math.Vector2, amount: float) -> seika.math.Vector2: Returns the linearly interpolated value of two points. Static functions that return specific values ZERO() -> Vector2(0.0, 0.0): LEFT() -> Vector2(-1.0, 0.0): RIGHT() -> Vector2(0.0, 1.0): UP() -> Vector2(0.0, -1.0): DOWN() -> Vector2(0.0, 1.0): Vector3 Engine representation of a two dimensional vector. Properties x : float X coordinate. y : float Y coordinate. z : float Z coordinate. Signals None. Methods None. Rect2 Engine representation of a rectangle vector. Properties x : float X coordinate. y : float Y coordinate. w : float Rectangle's width. h : float Rectangle's height. Signals None. Methods None.","title":"Math"},{"location":"python_api/math/#seikamath","text":"","title":"seika.math"},{"location":"python_api/math/#math","text":"Generic math functions","title":"Math"},{"location":"python_api/math/#properties","text":"None.","title":"Properties"},{"location":"python_api/math/#signals","text":"None.","title":"Signals"},{"location":"python_api/math/#methods","text":"lerp(source: float, destination: float, amount: float) -> float: Linearly interpolate between two values.","title":"Methods"},{"location":"python_api/math/#vector2","text":"Engine representation of a two-dimensional vector.","title":"Vector2"},{"location":"python_api/math/#properties_1","text":"x : float X coordinate. y : float Y coordinate.","title":"Properties"},{"location":"python_api/math/#signals_1","text":"None.","title":"Signals"},{"location":"python_api/math/#methods_1","text":"dot_product(value: seika.math.Vector2) -> float: Returns the dot product of two Vector2 items. lerp(source: seika.math.Vector2, destination: seika.math.Vector2, amount: float) -> seika.math.Vector2: Returns the linearly interpolated value of two points. Static functions that return specific values ZERO() -> Vector2(0.0, 0.0): LEFT() -> Vector2(-1.0, 0.0): RIGHT() -> Vector2(0.0, 1.0): UP() -> Vector2(0.0, -1.0): DOWN() -> Vector2(0.0, 1.0):","title":"Methods"},{"location":"python_api/math/#vector3","text":"Engine representation of a two dimensional vector.","title":"Vector3"},{"location":"python_api/math/#properties_2","text":"x : float X coordinate. y : float Y coordinate. z : float Z coordinate.","title":"Properties"},{"location":"python_api/math/#signals_2","text":"None.","title":"Signals"},{"location":"python_api/math/#methods_2","text":"None.","title":"Methods"},{"location":"python_api/math/#rect2","text":"Engine representation of a rectangle vector.","title":"Rect2"},{"location":"python_api/math/#properties_3","text":"x : float X coordinate. y : float Y coordinate. w : float Rectangle's width. h : float Rectangle's height.","title":"Properties"},{"location":"python_api/math/#signals_3","text":"None.","title":"Signals"},{"location":"python_api/math/#methods_3","text":"None.","title":"Methods"},{"location":"python_api/network/","text":"seika.network Network Interface for network related operations for multiplayer. Properties None. Signals Server and Client signals. peer_connected Emitted once a peer is connected to the Server . peer_disconnected Emitted once a peer is disconnected from the Server . message_received Emitted once a message is received from the network. Client only signals. connected_to_server Emitted once a client successfully connects to a Server . connection_to_server_failed Emitted once a client fails to connect to a Server . Methods connect_signal(signal_id: str, listener_node: seika.node.Node, function_name: str) -> None: Connects to network related signal. Server Interface for server related operations for multiplayer. Properties None. Signals None. Methods start(port: int) -> None: Starts server on designated port . stop() -> None: Stops previously started server. send_message_to_all_clients(message: str) -> None: Sends message to all connected clients. Client Interface for client related operations for multiplayer. Properties None. Signals None. Methods connect(endpoint: str, port: int) -> None: Connects to a server with the passed in endpoint and port . disconnect() -> None: Disconnects from a server. send_message_to_server(message:str) -> None: Sends message to the server.","title":"Network"},{"location":"python_api/network/#seikanetwork","text":"","title":"seika.network"},{"location":"python_api/network/#network","text":"Interface for network related operations for multiplayer.","title":"Network"},{"location":"python_api/network/#properties","text":"None.","title":"Properties"},{"location":"python_api/network/#signals","text":"Server and Client signals. peer_connected Emitted once a peer is connected to the Server . peer_disconnected Emitted once a peer is disconnected from the Server . message_received Emitted once a message is received from the network. Client only signals. connected_to_server Emitted once a client successfully connects to a Server . connection_to_server_failed Emitted once a client fails to connect to a Server .","title":"Signals"},{"location":"python_api/network/#methods","text":"connect_signal(signal_id: str, listener_node: seika.node.Node, function_name: str) -> None: Connects to network related signal.","title":"Methods"},{"location":"python_api/network/#server","text":"Interface for server related operations for multiplayer.","title":"Server"},{"location":"python_api/network/#properties_1","text":"None.","title":"Properties"},{"location":"python_api/network/#signals_1","text":"None.","title":"Signals"},{"location":"python_api/network/#methods_1","text":"start(port: int) -> None: Starts server on designated port . stop() -> None: Stops previously started server. send_message_to_all_clients(message: str) -> None: Sends message to all connected clients.","title":"Methods"},{"location":"python_api/network/#client","text":"Interface for client related operations for multiplayer.","title":"Client"},{"location":"python_api/network/#properties_2","text":"None.","title":"Properties"},{"location":"python_api/network/#signals_2","text":"None.","title":"Signals"},{"location":"python_api/network/#methods_2","text":"connect(endpoint: str, port: int) -> None: Connects to a server with the passed in endpoint and port . disconnect() -> None: Disconnects from a server. send_message_to_server(message:str) -> None: Sends message to the server.","title":"Methods"},{"location":"python_api/node/","text":"seika.node Node Inherits : N/A. Class used as an interface for scene node functionality. Base class for all scene node types. Properties name : str Unique name of node once added to the scene. entity_id : int Unique id of entity. Signals None. Methods queue_deletion() -> None: Queues a node to be deleted and removed from a scene if it's currently added to the scene tree. add_child(node: Node) -> None: Adds a node as a child to the current node. get_node(name: str) -> seika.node.Node: Returns a node with the given name. Will be None if node is not found. create_signal(signal_id: str) -> None: Creates a signal for subscribers to listen to. connect_signal(signal_id: str, listener_node: seika.node.Node, function_name: str) -> None: Connects source node's signal to listener node. emit_signal(signal_id: str, args=[]) -> None: Emits signal from source node. _start() -> None: Called when entity is loaded into scene tree with all dependencies and children. _physics_process(delta_time: float) -> None: Called every frame. delta_time is passed in to have a frame consistent with CPU speed. _end() -> None: Called before entity exits scene tree. Node2D Inherits : Node Class used as an interface for scene 2D functionality. Base class for all 2D scene node types. Properties position: seika.math.Vector2 Current position of entity. rotation: float Current rotation in degrees of entity. Signals None. Methods get_position() -> seika.math.Vector2: Get node's current position. set_position(value: seika.math.Vector2) -> None: Set node's current position. add_to_position(value: seika.math.Vector2) -> None: Add to node's current position. For example, if this line of code is within the _process function, the output of this line of code node.add_to_position(Vector(5, 10)) within 3 frames will be [(5, 10), (10, 20), (15, 30)] . Sprite Inherits : Node2D -> Node Class used to render a sprite entity. Properties flip_h: bool Detemines whether the x axis is flipped. flip_v: bool Detemines whether the y axis is flipped. Signals None. Methods None. AnimatedSprite Inherits : Node2D -> Node Class used to render an animated sprite entity. Properties is_playing: bool Returns True if an animation is currently playing. frame: int Current frame of animation. animation_frames: int Amount of frames for current animation. animation_speed: int Speed of current animation in milliseconds per frame. flip_h: bool Detemines whether the x axis is flipped. flip_v: bool Detemines whether the y axis is flipped. Signals animation_finished Emitted when an animations is finished. frame_changed Emitted when an animation frame changes. Methods play(animation_name: str, start_frame = 0) -> None: Plays animation based on the name passed in. set_animation(animation_name: str) -> None: Sets the current animation based on the name passed in. stop() -> None: Stops the currently playing animation. TextLabel Inherits : Node2D -> Node Class used to render font. Properties text: str Text Label's text. color: seika.color.Color Color of the text. Signals None. Methods get_text() -> str: Get node's label text. set_text(value: str) -> None: Set node's label text. CollisionShape2D Inherits : Node2D -> Node Class used to define collision shapes defined as rectangles. May add other collision shapes in the future. Properties collider_rect: seika.math.Rect2 Collision shape's colliding rectangle. color: seika.color.Color A collider's color. Only shown when colliders_visible is enabled in project properties . Signals None. Methods add_collision_exception(node: seika.node.Node) -> None: Adds a node to an exception list to ignore collisions. remove_collision_exception(node: seika.node.Node) -> None: Removes a node from an exception list. Collisions between nodes are enabled.","title":"Node"},{"location":"python_api/node/#seikanode","text":"","title":"seika.node"},{"location":"python_api/node/#node","text":"Inherits : N/A. Class used as an interface for scene node functionality. Base class for all scene node types.","title":"Node"},{"location":"python_api/node/#properties","text":"name : str Unique name of node once added to the scene. entity_id : int Unique id of entity.","title":"Properties"},{"location":"python_api/node/#signals","text":"None.","title":"Signals"},{"location":"python_api/node/#methods","text":"queue_deletion() -> None: Queues a node to be deleted and removed from a scene if it's currently added to the scene tree. add_child(node: Node) -> None: Adds a node as a child to the current node. get_node(name: str) -> seika.node.Node: Returns a node with the given name. Will be None if node is not found. create_signal(signal_id: str) -> None: Creates a signal for subscribers to listen to. connect_signal(signal_id: str, listener_node: seika.node.Node, function_name: str) -> None: Connects source node's signal to listener node. emit_signal(signal_id: str, args=[]) -> None: Emits signal from source node. _start() -> None: Called when entity is loaded into scene tree with all dependencies and children. _physics_process(delta_time: float) -> None: Called every frame. delta_time is passed in to have a frame consistent with CPU speed. _end() -> None: Called before entity exits scene tree.","title":"Methods"},{"location":"python_api/node/#node2d","text":"Inherits : Node Class used as an interface for scene 2D functionality. Base class for all 2D scene node types.","title":"Node2D"},{"location":"python_api/node/#properties_1","text":"position: seika.math.Vector2 Current position of entity. rotation: float Current rotation in degrees of entity.","title":"Properties"},{"location":"python_api/node/#signals_1","text":"None.","title":"Signals"},{"location":"python_api/node/#methods_1","text":"get_position() -> seika.math.Vector2: Get node's current position. set_position(value: seika.math.Vector2) -> None: Set node's current position. add_to_position(value: seika.math.Vector2) -> None: Add to node's current position. For example, if this line of code is within the _process function, the output of this line of code node.add_to_position(Vector(5, 10)) within 3 frames will be [(5, 10), (10, 20), (15, 30)] .","title":"Methods"},{"location":"python_api/node/#sprite","text":"Inherits : Node2D -> Node Class used to render a sprite entity.","title":"Sprite"},{"location":"python_api/node/#properties_2","text":"flip_h: bool Detemines whether the x axis is flipped. flip_v: bool Detemines whether the y axis is flipped.","title":"Properties"},{"location":"python_api/node/#signals_2","text":"None.","title":"Signals"},{"location":"python_api/node/#methods_2","text":"None.","title":"Methods"},{"location":"python_api/node/#animatedsprite","text":"Inherits : Node2D -> Node Class used to render an animated sprite entity.","title":"AnimatedSprite"},{"location":"python_api/node/#properties_3","text":"is_playing: bool Returns True if an animation is currently playing. frame: int Current frame of animation. animation_frames: int Amount of frames for current animation. animation_speed: int Speed of current animation in milliseconds per frame. flip_h: bool Detemines whether the x axis is flipped. flip_v: bool Detemines whether the y axis is flipped.","title":"Properties"},{"location":"python_api/node/#signals_3","text":"animation_finished Emitted when an animations is finished. frame_changed Emitted when an animation frame changes.","title":"Signals"},{"location":"python_api/node/#methods_3","text":"play(animation_name: str, start_frame = 0) -> None: Plays animation based on the name passed in. set_animation(animation_name: str) -> None: Sets the current animation based on the name passed in. stop() -> None: Stops the currently playing animation.","title":"Methods"},{"location":"python_api/node/#textlabel","text":"Inherits : Node2D -> Node Class used to render font.","title":"TextLabel"},{"location":"python_api/node/#properties_4","text":"text: str Text Label's text. color: seika.color.Color Color of the text.","title":"Properties"},{"location":"python_api/node/#signals_4","text":"None.","title":"Signals"},{"location":"python_api/node/#methods_4","text":"get_text() -> str: Get node's label text. set_text(value: str) -> None: Set node's label text.","title":"Methods"},{"location":"python_api/node/#collisionshape2d","text":"Inherits : Node2D -> Node Class used to define collision shapes defined as rectangles. May add other collision shapes in the future.","title":"CollisionShape2D"},{"location":"python_api/node/#properties_5","text":"collider_rect: seika.math.Rect2 Collision shape's colliding rectangle. color: seika.color.Color A collider's color. Only shown when colliders_visible is enabled in project properties .","title":"Properties"},{"location":"python_api/node/#signals_5","text":"None.","title":"Signals"},{"location":"python_api/node/#methods_5","text":"add_collision_exception(node: seika.node.Node) -> None: Adds a node to an exception list to ignore collisions. remove_collision_exception(node: seika.node.Node) -> None: Removes a node from an exception list. Collisions between nodes are enabled.","title":"Methods"},{"location":"python_api/physics/","text":"seika.physics Collision Interface for collisions between entities. Properties None. Signals None. Methods get_collided_nodes(node: seika.node.Node) -> bool: Returns a list of nodes that collided with the passed in node .","title":"Physics"},{"location":"python_api/physics/#seikaphysics","text":"","title":"seika.physics"},{"location":"python_api/physics/#collision","text":"Interface for collisions between entities.","title":"Collision"},{"location":"python_api/physics/#properties","text":"None.","title":"Properties"},{"location":"python_api/physics/#signals","text":"None.","title":"Signals"},{"location":"python_api/physics/#methods","text":"get_collided_nodes(node: seika.node.Node) -> bool: Returns a list of nodes that collided with the passed in node .","title":"Methods"},{"location":"python_api/scene/","text":"seika.scene Scene Tree Represents the scene tree which handles operations related to the scene system. Properties None. Signals None. Methods change_scene(scene_path: str) -> None: Change the scene to the current scene defined by scene_path . get_current_scene_node() -> seika.node.Node: Returns the root node of the current scene.","title":"Scene"},{"location":"python_api/scene/#seikascene","text":"","title":"seika.scene"},{"location":"python_api/scene/#scene-tree","text":"Represents the scene tree which handles operations related to the scene system.","title":"Scene Tree"},{"location":"python_api/scene/#properties","text":"None.","title":"Properties"},{"location":"python_api/scene/#signals","text":"None.","title":"Signals"},{"location":"python_api/scene/#methods","text":"change_scene(scene_path: str) -> None: Change the scene to the current scene defined by scene_path . get_current_scene_node() -> seika.node.Node: Returns the root node of the current scene.","title":"Methods"}]}