#ifndef PYTHON_SOURCE_H
#define PYTHON_SOURCE_H

// Seika Engine API v0.13.2

using PythonSource = const std::string&;

static PythonSource PYTHON_SOURCE_ASSETS_MODULE =
    "from enum import Enum\n"
    "from typing import List\n"
    "\n"
    "import seika_engine_api\n"
    "from seika.color import Color\n"
    "from seika.math import Vector2, Rect2\n"
    "\n"
    "\n"
    "class Texture:\n"
    "   class Wrap(str, Enum):\n"
    "       CLAMP_TO_BORDER = \"clamp_to_border\"\n"
    "       REPEAT = \"repeat\"\n"
    "\n"
    "   class FILTER(str, Enum):\n"
    "       NEAREST = \"nearest\"\n"
    "       LINEAR = \"linear\"\n"
    "\n"
    "   def __init__(\n"
    "       self,\n"
    "       file_path: str,\n"
    "       wrap_s=Wrap.CLAMP_TO_BORDER,\n"
    "       wrap_t=Wrap.CLAMP_TO_BORDER,\n"
    "       filter_min=FILTER.NEAREST,\n"
    "       filter_max=FILTER.NEAREST,\n"
    "       width=0,\n"
    "       height=0,\n"
    "   ):\n"
    "       self._file_path = file_path\n"
    "       self._wrap_s = wrap_s\n"
    "       self._wrap_t = wrap_t\n"
    "       self._filter_min = filter_min\n"
    "       self._filter_max = filter_max\n"
    "       self._width = width\n"
    "       self._height = height\n"
    "\n"
    "   @property\n"
    "   def file_path(self) -> str:\n"
    "       return self._file_path\n"
    "\n"
    "   @property\n"
    "   def wrap_s(self) -> str:\n"
    "       return self._wrap_s\n"
    "\n"
    "   @property\n"
    "   def wrap_t(self) -> str:\n"
    "       return self._wrap_t\n"
    "\n"
    "   @property\n"
    "   def filter_min(self) -> str:\n"
    "       return self._filter_min\n"
    "\n"
    "   @property\n"
    "   def filter_max(self) -> str:\n"
    "       return self._filter_max\n"
    "\n"
    "   @property\n"
    "   def width(self) -> int:\n"
    "       return self._width\n"
    "\n"
    "   @property\n"
    "   def height(self) -> int:\n"
    "       return self._height\n"
    "\n"
    "   @staticmethod\n"
    "   def get(file_path: str):\n"
    "       (\n"
    "           wrap_s,\n"
    "           wrap_t,\n"
    "           filter_min,\n"
    "           filter_max,\n"
    "           width,\n"
    "           height,\n"
    "       ) = seika_engine_api.texture_get(file_path=file_path)\n"
    "       return Texture(\n"
    "           file_path=file_path,\n"
    "           wrap_s=wrap_s,\n"
    "           wrap_t=wrap_t,\n"
    "           filter_min=filter_min,\n"
    "           filter_max=filter_max,\n"
    "           width=width,\n"
    "           height=height,\n"
    "       )\n"
    "\n"
    "   def get_pixel_color(self, position: Vector2) -> Color:\n"
    "       red, green, blue, alpha = seika_engine_api.texture_get_pixel_color(\n"
    "           file_path=self.file_path, x=position.x, y=position.y\n"
    "       )\n"
    "       return Color(r=red, g=green, b=blue, a=alpha)\n"
    "\n"
    "   def __str__(self):\n"
    "       return f\"Texture(file_path: {self._file_path}, wrap_s: {self._wrap_s}, wrap_t: {self._wrap_t}, filter_min: {self._filter_min}, filter_min: {self._filter_max}, width: {self._width}, height: {self._height})\"\n"
    "\n"
    "   def __repr__(self):\n"
    "       return f\"Texture(file_path: {self._file_path}, wrap_s: {self._wrap_s}, wrap_t: {self._wrap_t}, filter_min: {self._filter_min}, filter_min: {self._filter_max}, width: {self._width}, height: {self._height})\"\n"
    "\n"
    "\n"
    "class AnimationFrame:\n"
    "   def __init__(self, texture: Texture, draw_source: Rect2, index: int):\n"
    "       self.texture = texture\n"
    "       self.draw_source = draw_source\n"
    "       self.index = index\n"
    "\n"
    "\n"
    "class Animation:\n"
    "   def __init__(self, name: str, speed: int, frames: List[AnimationFrame]):\n"
    "       self.name = name\n"
    "       self.speed = speed\n"
    "       self.frames = frames\n"
    "\n"
    "\n"
    "class Font:\n"
    "   def __init__(self, uid: str, file_path: str, size: int):\n"
    "       self._uid = uid\n"
    "       self._file_path = file_path\n"
    "       self._size = size\n"
    "\n"
    "   @property\n"
    "   def uid(self) -> str:\n"
    "       return self._uid\n"
    "\n"
    "   @property\n"
    "   def file_path(self) -> str:\n"
    "       return self._file_path\n"
    "\n"
    "   @property\n"
    "   def size(self) -> int:\n"
    "       return self._size\n"
    "\n"
    "   @staticmethod\n"
    "   def create(uid: str, file_path: str, size: int):\n"
    "       seika_engine_api.font_create(uid=uid, file_path=file_path, size=size)\n"
    "       return Font(uid=uid, file_path=file_path, size=size)\n"
    "\n"
    "   @staticmethod\n"
    "   def get(uid: str):\n"
    "       file_path, size = seika_engine_api.font_get(uid=uid)\n"
    "       return Font(uid=uid, file_path=file_path, size=size)\n"
    "\n"
    "   def __str__(self):\n"
    "       return (\n"
    "           f\"Font(uid: {self._uid}, file_path: {self._file_path}, size: {self._size})\"\n"
    "       )\n"
    "\n"
    "   def __repr__(self):\n"
    "       return (\n"
    "           f\"Font(uid: {self._uid}, file_path: {self._file_path}, size: {self._size})\"\n"
    "       )\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_AUDIO_MODULE =
    "import seika_engine_api\n"
    "\n"
    "\n"
    "class Audio:\n"
    "   @staticmethod\n"
    "   def play_music(music_id: str, loops=True) -> None:\n"
    "       seika_engine_api.audio_play_music(music_id=music_id, loops=loops)\n"
    "\n"
    "   @staticmethod\n"
    "   def stop_music() -> None:\n"
    "       seika_engine_api.audio_stop_music()\n"
    "\n"
    "   @staticmethod\n"
    "   def set_music_volume(volume: int) -> None:\n"
    "       seika_engine_api.audio_set_music_volume(volume=volume)\n"
    "\n"
    "   @staticmethod\n"
    "   def play_sound(sound_id: str) -> None:\n"
    "       seika_engine_api.audio_play_sound(sound_id=sound_id)\n"
    "\n"
    "   @staticmethod\n"
    "   def set_sound_volume(volume: int) -> None:\n"
    "       seika_engine_api.audio_set_sound_volume(volume=volume)\n"
    "\n"
    "   @staticmethod\n"
    "   def set_all_volume(volume: int) -> None:\n"
    "       seika_engine_api.audio_set_all_volume(volume=volume)\n"
    "\n"
    "\n"
    "class AudioStream:\n"
    "   @staticmethod\n"
    "   def get(stream_uid: str):\n"
    "       pitch, gain, does_loop = seika_engine_api.audio_stream_get(uid=stream_uid)\n"
    "       return AudioStream(uid=stream_uid, pitch=pitch, gain=gain, loops=does_loop)\n"
    "\n"
    "   def __init__(self, uid: str, pitch: float, gain: float, loops: bool):\n"
    "       self._uid = uid\n"
    "       self._pitch = pitch\n"
    "       self._gain = gain\n"
    "       self._loops = loops\n"
    "\n"
    "   @property\n"
    "   def uid(self) -> str:\n"
    "       return self._uid\n"
    "\n"
    "   @property\n"
    "   def pitch(self) -> float:\n"
    "       return self._pitch\n"
    "\n"
    "   @pitch.setter\n"
    "   def pitch(self, value: float) -> None:\n"
    "       seika_engine_api.audio_stream_set_pitch(uid=self._uid, pitch=value)\n"
    "\n"
    "   @property\n"
    "   def gain(self) -> float:\n"
    "       return self._gain\n"
    "\n"
    "   @gain.setter\n"
    "   def gain(self, value: float) -> None:\n"
    "       seika_engine_api.audio_stream_set_gain(uid=self._uid, gain=value)\n"
    "\n"
    "   @property\n"
    "   def loops(self) -> bool:\n"
    "       return self._loops\n"
    "\n"
    "   @loops.setter\n"
    "   def loops(self, value: bool) -> None:\n"
    "       seika_engine_api.audio_stream_set_loops(uid=self._uid, loops=value)\n"
    "\n"
    "   @property\n"
    "   def is_playing(self) -> bool:\n"
    "       return seika_engine_api.audio_stream_is_playing(uid=self._uid)\n"
    "\n"
    "   def play(self) -> None:\n"
    "       seika_engine_api.audio_stream_play(uid=self._uid)\n"
    "\n"
    "   def stop(self) -> None:\n"
    "       seika_engine_api.audio_stream_stop(uid=self._uid)\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_CAMERA_MODULE =
    "import seika_engine_api\n"
    "from seika.math import Vector2\n"
    "\n"
    "\n"
    "class Camera2D:\n"
    "   @staticmethod\n"
    "   def get_zoom() -> Vector2:\n"
    "       zoom_x, zoom_y = seika_engine_api.camera2d_get_zoom()\n"
    "       return Vector2(zoom_x, zoom_y)\n"
    "\n"
    "   @staticmethod\n"
    "   def set_zoom(zoom: Vector2) -> None:\n"
    "       seika_engine_api.camera2d_set_zoom(zoom.x, zoom.y)\n"
    "\n"
    "   @staticmethod\n"
    "   def get_viewport_position() -> Vector2:\n"
    "       viewport_x, viewport_y = seika_engine_api.camera2d_get_viewport_position()\n"
    "       return Vector2(viewport_x, viewport_y)\n"
    "\n"
    "   @staticmethod\n"
    "   def set_viewport_position(position: Vector2) -> None:\n"
    "       seika_engine_api.camera2d_set_viewport_position(position.x, position.y)\n"
    "\n"
    "   @staticmethod\n"
    "   def get_offset() -> Vector2:\n"
    "       zoom_x, zoom_y = seika_engine_api.camera2d_get_offset()\n"
    "       return Vector2(zoom_x, zoom_y)\n"
    "\n"
    "   @staticmethod\n"
    "   def set_offset(offset: Vector2) -> None:\n"
    "       seika_engine_api.camera2d_set_offset(offset.x, offset.y)\n"
    "\n"
    "\n"
    "class Camera3D:\n"
    "   @staticmethod\n"
    "   def move_left(speed: float) -> None:\n"
    "       seika_engine_api.camera3d_move_left(speed=speed)\n"
    "\n"
    "   @staticmethod\n"
    "   def move_right(speed: float) -> None:\n"
    "       seika_engine_api.camera3d_move_right(speed=speed)\n"
    "\n"
    "   @staticmethod\n"
    "   def move_up(speed: float) -> None:\n"
    "       seika_engine_api.camera3d_move_up(speed=speed)\n"
    "\n"
    "   @staticmethod\n"
    "   def move_down(speed: float) -> None:\n"
    "       seika_engine_api.camera3d_move_down(speed=speed)\n"
    "\n"
    "   @staticmethod\n"
    "   def add_yaw(yaw: float) -> None:\n"
    "       seika_engine_api.camera3d_add_yaw(yaw=yaw)\n"
    "\n"
    "   @staticmethod\n"
    "   def add_pitch(pitch: float) -> None:\n"
    "       seika_engine_api.camera3d_add_pitch(pitch=pitch)\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_COLOR_MODULE =
    "class Color:\n"
    "   def __init__(self, r=0.0, g=0.0, b=0.0, a=1.0):\n"
    "       self.r = r\n"
    "       self.g = g\n"
    "       self.b = b\n"
    "       self.a = a\n"
    "\n"
    "   def __str__(self):\n"
    "       return f\"({self.r}, {self.g}, {self.b}, {self.a})\"\n"
    "\n"
    "   def __repr__(self):\n"
    "       return f\"({self.r}, {self.g}, {self.b}, {self.a})\"\n"
    "\n"
    "   def get_full_color(self):\n"
    "       return Color(\n"
    "           int(self.r * 255), int(self.g * 255), int(self.b * 255), int(self.a * 255)\n"
    "       )\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_DATA_MODULE =
    "import json\n"
    "from typing import Optional\n"
    "\n"
    "import seika_engine_api\n"
    "\n"
    "\n"
    "class ConfigTool:\n"
    "   def __init__(self, file_path: str, initial_data: Optional[dict] = None):\n"
    "       if initial_data is None:\n"
    "           initial_data = {}\n"
    "       self._data = initial_data\n"
    "       self.file_path = file_path\n"
    "\n"
    "   @property\n"
    "   def data(self) -> dict:\n"
    "       return self._data\n"
    "\n"
    "   @data.setter\n"
    "   def data(self, value: dict) -> None:\n"
    "       self._data = value\n"
    "\n"
    "   def save_file(self, encryption_key: Optional[str] = None) -> bool:\n"
    "       if len(self._data) > 0:\n"
    "           if not encryption_key:\n"
    "               encryption_key = \"\"\n"
    "           seika_engine_api.config_tool_save_file(\n"
    "               file_path=self.file_path,\n"
    "               json_data=json.dumps(self._data),\n"
    "               encryption_key=encryption_key,\n"
    "           )\n"
    "           return True\n"
    "       return False\n"
    "\n"
    "   def load_file(self, encryption_key: Optional[str] = None) -> bool:\n"
    "       if self.does_file_exist():\n"
    "           if not encryption_key:\n"
    "               encryption_key = \"\"\n"
    "           save_data = seika_engine_api.config_tool_load_file(\n"
    "               file_path=self.file_path, encryption_key=encryption_key\n"
    "           )\n"
    "           self._data = json.loads(save_data)\n"
    "           return True\n"
    "       return False\n"
    "\n"
    "   def delete_file(self) -> bool:\n"
    "       return seika_engine_api.config_tool_delete_file(file_path=self.file_path)\n"
    "\n"
    "   def does_file_exist(self) -> bool:\n"
    "       return seika_engine_api.config_tool_does_file_exist(file_path=self.file_path)\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_ENGINE_MODULE =
    "import seika_engine_api\n"
    "\n"
    "\n"
    "class Engine:\n"
    "   @staticmethod\n"
    "   def exit(code: int = 0) -> None:\n"
    "       seika_engine_api.engine_exit(code=code)\n"
    "\n"
    "   @staticmethod\n"
    "   def get_fps() -> float:\n"
    "       return seika_engine_api.engine_get_fps()\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_INPUT_MODULE =
    "import seika_engine_api\n"
    "from seika.math import Vector2\n"
    "\n"
    "\n"
    "class Input:\n"
    "   @staticmethod\n"
    "   def add_action(action_name: str, value: str) -> None:\n"
    "       seika_engine_api.input_add_action(action_name=action_name, value=value)\n"
    "\n"
    "   @staticmethod\n"
    "   def is_action_pressed(action_name: str) -> bool:\n"
    "       return seika_engine_api.input_is_action_pressed(action_name=action_name)\n"
    "\n"
    "   @staticmethod\n"
    "   def is_action_just_pressed(action_name: str) -> bool:\n"
    "       return seika_engine_api.input_is_action_just_pressed(action_name=action_name)\n"
    "\n"
    "   @staticmethod\n"
    "   def is_action_just_released(action_name: str) -> bool:\n"
    "       return seika_engine_api.input_is_action_just_released(action_name=action_name)\n"
    "\n"
    "\n"
    "class Mouse:\n"
    "   LEFT_BUTTON = \"mb_left\"\n"
    "   RIGHT_BUTTON = \"mb_right\"\n"
    "\n"
    "   @staticmethod\n"
    "   def get_position() -> Vector2:\n"
    "       mouse_x, mouse_y = seika_engine_api.mouse_get_position()\n"
    "       return Vector2(mouse_x, mouse_y)\n"
    "\n"
    "\n"
    "class Keyboard:\n"
    "   NUM_0 = \"0\"\n"
    "   NUM_1 = \"1\"\n"
    "   NUM_2 = \"2\"\n"
    "   NUM_3 = \"3\"\n"
    "   NUM_4 = \"4\"\n"
    "   NUM_5 = \"5\"\n"
    "   NUM_6 = \"6\"\n"
    "   NUM_7 = \"7\"\n"
    "   NUM_8 = \"8\"\n"
    "   NUM_9 = \"9\"\n"
    "\n"
    "   A = \"a\"\n"
    "   B = \"b\"\n"
    "   C = \"c\"\n"
    "   D = \"d\"\n"
    "   E = \"e\"\n"
    "   F = \"f\"\n"
    "   G = \"g\"\n"
    "   H = \"h\"\n"
    "   I = \"i\"\n"
    "   J = \"j\"\n"
    "   K = \"k\"\n"
    "   L = \"l\"\n"
    "   M = \"m\"\n"
    "   N = \"n\"\n"
    "   O = \"o\"\n"
    "   P = \"p\"\n"
    "   Q = \"q\"\n"
    "   R = \"r\"\n"
    "   S = \"s\"\n"
    "   T = \"t\"\n"
    "   U = \"u\"\n"
    "   V = \"v\"\n"
    "   W = \"w\"\n"
    "   X = \"x\"\n"
    "   Y = \"y\"\n"
    "   Z = \"z\"\n"
    "\n"
    "   UP = \"up\"\n"
    "   DOWN = \"down\"\n"
    "   LEFT = \"left\"\n"
    "   RIGHT = \"right\"\n"
    "   SPACE = \"space\"\n"
    "   ESC = \"esc\"\n"
    "   RETURN = \"return\"\n"
    "\n"
    "   F1 = \"f1\"\n"
    "   F2 = \"f2\"\n"
    "   F3 = \"f3\"\n"
    "   F4 = \"f4\"\n"
    "   F5 = \"f5\"\n"
    "   F6 = \"f6\"\n"
    "   F7 = \"f7\"\n"
    "   F8 = \"f8\"\n"
    "   F9 = \"f9\"\n"
    "   F10 = \"f10\"\n"
    "   F11 = \"f11\"\n"
    "   F12 = \"f12\"\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_MATH_MODULE =
    "import math\n"
    "\n"
    "\n"
    "class Math:\n"
    "   PI = 3.14159\n"
    "\n"
    "   @staticmethod\n"
    "   def lerp(source: float, destination: float, amount: float) -> float:\n"
    "       return source + (destination - source) * amount\n"
    "\n"
    "\n"
    "class Vector2:\n"
    "   def __init__(self, x=0.0, y=0.0):\n"
    "       self.x = x\n"
    "       self.y = y\n"
    "\n"
    "   def dot_product(self, other) -> float:\n"
    "       return (self.x * other.x) + (self.y * other.y)\n"
    "\n"
    "   def __eq__(self, other) -> bool:\n"
    "       if self.x == other.x and self.y == other.y:\n"
    "           return True\n"
    "       else:\n"
    "           return False\n"
    "\n"
    "   def __gt__(self, other) -> bool:\n"
    "       if self.x + self.y > other.x + other.y:\n"
    "           return True\n"
    "       else:\n"
    "           return False\n"
    "\n"
    "   def __lt__(self, other) -> bool:\n"
    "       if self.x + self.y < other.x + other.y:\n"
    "           return True\n"
    "       else:\n"
    "           return False\n"
    "\n"
    "   def __sub__(self, other):\n"
    "       return Vector2(self.x - other.x, self.y - other.y)\n"
    "\n"
    "   def __add__(self, other):\n"
    "       return Vector2(self.x + other.x, self.y + other.y)\n"
    "\n"
    "   def __mul__(self, other):\n"
    "       return Vector2(self.x * other.x, self.y * other.y)\n"
    "\n"
    "   def __truediv__(self, other):\n"
    "       return Vector2(self.x / other.x, self.y / other.y)\n"
    "\n"
    "   def __str__(self):\n"
    "       return f\"({self.x}, {self.y})\"\n"
    "\n"
    "   def __repr__(self):\n"
    "       return f\"({self.x}, {self.y})\"\n"
    "\n"
    "   @staticmethod\n"
    "   def lerp(source, destination, amount: float) -> float:\n"
    "       return source + (destination - source) * Vector2(amount, amount)\n"
    "\n"
    "   @staticmethod\n"
    "   def ZERO():\n"
    "       return Vector2(0.0, 0.0)\n"
    "\n"
    "   @staticmethod\n"
    "   def LEFT():\n"
    "       return Vector2(-1.0, 0.0)\n"
    "\n"
    "   @staticmethod\n"
    "   def RIGHT():\n"
    "       return Vector2(1.0, 0.0)\n"
    "\n"
    "   @staticmethod\n"
    "   def UP():\n"
    "       return Vector2(0.0, -1.0)\n"
    "\n"
    "   @staticmethod\n"
    "   def DOWN():\n"
    "       return Vector2(0.0, 1.0)\n"
    "\n"
    "\n"
    "class Vector3:\n"
    "   def __init__(self, x=0.0, y=0.0, z=0.0):\n"
    "       self.x = x\n"
    "       self.y = y\n"
    "       self.z = z\n"
    "\n"
    "   def __eq__(self, other) -> bool:\n"
    "       if self.x == other.x and self.y == other.y and self.z == other.z:\n"
    "           return True\n"
    "       else:\n"
    "           return False\n"
    "\n"
    "   def __gt__(self, other) -> bool:\n"
    "       if self.x + self.y + self.z > other.x + other.y + other.z:\n"
    "           return True\n"
    "       else:\n"
    "           return False\n"
    "\n"
    "   def __lt__(self, other) -> bool:\n"
    "       if self.x + self.y + self.z < other.x + other.y + other.z:\n"
    "           return True\n"
    "       else:\n"
    "           return False\n"
    "\n"
    "   def __sub__(self, other):\n"
    "       return Vector3(self.x - other.x, self.y - other.y, self.z - other.z)\n"
    "\n"
    "   def __add__(self, other):\n"
    "       return Vector3(self.x + other.x, self.y + other.y, self.z + other.z)\n"
    "\n"
    "   def __mul__(self, other):\n"
    "       return Vector3(self.x * other.x, self.y * other.y, self.z * other.z)\n"
    "\n"
    "   def __truediv__(self, other):\n"
    "       return Vector3(self.x / other.x, self.y / other.y, self.z / other.z)\n"
    "\n"
    "   def __str__(self):\n"
    "       return f\"({self.x}, {self.y}, {self.z})\"\n"
    "\n"
    "   def __repr__(self):\n"
    "       return f\"({self.x}, {self.y}, {self.z})\"\n"
    "\n"
    "\n"
    "class Rect2:\n"
    "   def __init__(self, x=0.0, y=0.0, w=0.0, h=0.0):\n"
    "       self.x = x\n"
    "       self.y = y\n"
    "       self.w = w\n"
    "       self.h = h\n"
    "\n"
    "   def __str__(self):\n"
    "       return f\"({self.x}, {self.y}, {self.w}, {self.h})\"\n"
    "\n"
    "   def __repr__(self):\n"
    "       return f\"({self.x}, {self.y}, {self.w}, {self.h})\"\n"
    "\n"
    "   @property\n"
    "   def position(self) -> Vector2:\n"
    "       return Vector2(self.x, self.y)\n"
    "\n"
    "   @position.setter\n"
    "   def position(self, value: Vector2) -> None:\n"
    "       self.x = value.x\n"
    "       self.y = value.y\n"
    "\n"
    "   @property\n"
    "   def size(self) -> Vector2:\n"
    "       return Vector2(self.w, self.h)\n"
    "\n"
    "   @size.setter\n"
    "   def size(self, value: Vector2) -> None:\n"
    "       self.w = value.x\n"
    "       self.h = value.y\n"
    "\n"
    "\n"
    "class Ease:\n"
    "   class Cubic:\n"
    "       @staticmethod\n"
    "       def ease_in(\n"
    "           elapsed_time: float, from_pos: float, to_pos: float, duration: float\n"
    "       ) -> float:\n"
    "           change = to_pos - from_pos\n"
    "           elapsed_time = elapsed_time / duration\n"
    "           return change * elapsed_time * elapsed_time * elapsed_time + from_pos\n"
    "\n"
    "       @staticmethod\n"
    "       def ease_out(\n"
    "           elapsed_time: float, from_pos: float, to_pos: float, duration: float\n"
    "       ) -> float:\n"
    "           change = to_pos - from_pos\n"
    "           elapsed_time = elapsed_time / duration - 1\n"
    "           return change * (elapsed_time * elapsed_time * elapsed_time + 1) + from_pos\n"
    "\n"
    "       @staticmethod\n"
    "       def ease_in_vec2(\n"
    "           elapsed_time: float, from_pos: Vector2, to_pos: Vector2, duration: float\n"
    "       ) -> Vector2:\n"
    "           return Vector2(\n"
    "               Ease.Cubic.ease_in(elapsed_time, from_pos.x, to_pos.x, duration),\n"
    "               Ease.Cubic.ease_in(elapsed_time, from_pos.t, to_pos.y, duration),\n"
    "           )\n"
    "\n"
    "       @staticmethod\n"
    "       def ease_out_vec2(\n"
    "           elapsed_time: float, from_pos: Vector2, to_pos: Vector2, duration: float\n"
    "       ) -> Vector2:\n"
    "           return Vector2(\n"
    "               Ease.Cubic.ease_out(elapsed_time, from_pos.x, to_pos.x, duration),\n"
    "               Ease.Cubic.ease_out(elapsed_time, from_pos.t, to_pos.y, duration),\n"
    "           )\n"
    "\n"
    "   class Bounce:\n"
    "       @staticmethod\n"
    "       def ease_in(\n"
    "           elapsed_time: float, from_pos: float, to_pos: float, duration: float\n"
    "       ) -> float:\n"
    "           change = to_pos - from_pos\n"
    "           return (\n"
    "               change\n"
    "               - Ease.Bounce.ease_out(elapsed_time, from_pos, to_pos, duration)\n"
    "               + from_pos\n"
    "           )\n"
    "\n"
    "       @staticmethod\n"
    "       def ease_out(\n"
    "           elapsed_time: float, from_pos: float, to_pos: float, duration: float\n"
    "       ) -> float:\n"
    "           change = to_pos - from_pos\n"
    "           elapsed_time = elapsed_time / duration\n"
    "           if elapsed_time < 1 / 2.75:\n"
    "               return change * (7.5625 * elapsed_time * elapsed_time) + from_pos\n"
    "           elif elapsed_time < 2 / 2.75:\n"
    "               elapsed_time = elapsed_time - (1.5 / 2.75)\n"
    "               return change * (7.5625 * elapsed_time * elapsed_time + 0.75) + from_pos\n"
    "           elif elapsed_time < 2.5 / 2.75:\n"
    "               elapsed_time = elapsed_time - (2.25 / 2.75)\n"
    "               return (\n"
    "                   change * (7.5625 * elapsed_time * elapsed_time + 0.9375) + from_pos\n"
    "               )\n"
    "           else:\n"
    "               elapsed_time = elapsed_time - (2.626 / 2.75)\n"
    "               return (\n"
    "                   change * (7.5625 * elapsed_time * elapsed_time + 0.984375)\n"
    "                   + from_pos\n"
    "               )\n"
    "\n"
    "       @staticmethod\n"
    "       def ease_in_vec2(\n"
    "           elapsed_time: float, from_pos: Vector2, to_pos: Vector2, duration: float\n"
    "       ) -> Vector2:\n"
    "           return Vector2(\n"
    "               Ease.Bounce.ease_in(elapsed_time, from_pos.x, to_pos.x, duration),\n"
    "               Ease.Bounce.ease_in(elapsed_time, from_pos.t, to_pos.y, duration),\n"
    "           )\n"
    "\n"
    "       @staticmethod\n"
    "       def ease_out_vec2(\n"
    "           elapsed_time: float, from_pos: Vector2, to_pos: Vector2, duration: float\n"
    "       ) -> Vector2:\n"
    "           return Vector2(\n"
    "               Ease.Bounce.ease_out(elapsed_time, from_pos.x, to_pos.x, duration),\n"
    "               Ease.Bounce.ease_out(elapsed_time, from_pos.t, to_pos.y, duration),\n"
    "           )\n"
    "\n"
    "   class Elastic:\n"
    "       @staticmethod\n"
    "       def ease_in(\n"
    "           elapsed_time: float,\n"
    "           from_pos: float,\n"
    "           to_pos: float,\n"
    "           duration: float,\n"
    "           amplitude=0.0,\n"
    "           period=0.0,\n"
    "       ) -> float:\n"
    "           change = to_pos - from_pos\n"
    "           if elapsed_time == 0:\n"
    "               return from_pos\n"
    "           elapsed_time = elapsed_time / duration\n"
    "           if elapsed_time == 1:\n"
    "               return from_pos + change\n"
    "\n"
    "           if period == 0:\n"
    "               period = duration * 0.3\n"
    "\n"
    "           if amplitude == 0 or amplitude < abs(change):\n"
    "               amplitude = change\n"
    "               s = period / 4\n"
    "           else:\n"
    "               s = period / (2 * Math.PI) * math.asin(change / amplitude)\n"
    "\n"
    "           elapsed_time = elapsed_time - 1\n"
    "           return (\n"
    "               -(\n"
    "                   amplitude\n"
    "                   * math.pow(2, 10 * elapsed_time)\n"
    "                   * math.sin((elapsed_time * duration - s) * (2 * Math.PI) / period)\n"
    "               )\n"
    "               + from_pos\n"
    "           )\n"
    "\n"
    "       @staticmethod\n"
    "       def ease_out(\n"
    "           elapsed_time: float,\n"
    "           from_pos: float,\n"
    "           to_pos: float,\n"
    "           duration: float,\n"
    "           amplitude=0.0,\n"
    "           period=0.0,\n"
    "       ) -> float:\n"
    "           change = to_pos - from_pos\n"
    "           if elapsed_time == 0:\n"
    "               return from_pos\n"
    "           elapsed_time = elapsed_time / duration\n"
    "           if elapsed_time == 1:\n"
    "               return from_pos + change\n"
    "\n"
    "           if period == 0:\n"
    "               period = duration * 0.3\n"
    "\n"
    "           if amplitude == 0:\n"
    "               amplitude = change\n"
    "               s = period / 4\n"
    "           else:\n"
    "               s = period / (2 * Math.PI) * math.asin(change / amplitude)\n"
    "\n"
    "           return (\n"
    "               amplitude\n"
    "               * math.pow(2, -10 * elapsed_time)\n"
    "               * math.sin((elapsed_time * duration - s) * (2 * Math.PI) / period)\n"
    "               + change\n"
    "               + from_pos\n"
    "           )\n"
    "\n"
    "       @staticmethod\n"
    "       def ease_in_vec2(\n"
    "           elapsed_time: float,\n"
    "           from_pos: Vector2,\n"
    "           to_pos: Vector2,\n"
    "           duration: float,\n"
    "           amplitude=0.0,\n"
    "           period=0.0,\n"
    "       ) -> Vector2:\n"
    "           return Vector2(\n"
    "               Ease.Elastic.ease_in(\n"
    "                   elapsed_time, from_pos.x, to_pos.x, duration, amplitude, period\n"
    "               ),\n"
    "               Ease.Elastic.ease_in(\n"
    "                   elapsed_time, from_pos.t, to_pos.y, duration, amplitude, period\n"
    "               ),\n"
    "           )\n"
    "\n"
    "       @staticmethod\n"
    "       def ease_out_vec2(\n"
    "           elapsed_time: float,\n"
    "           from_pos: Vector2,\n"
    "           to_pos: Vector2,\n"
    "           duration: float,\n"
    "           amplitude=0.0,\n"
    "           period=0.0,\n"
    "       ) -> Vector2:\n"
    "           return Vector2(\n"
    "               Ease.Elastic.ease_out(\n"
    "                   elapsed_time, from_pos.x, to_pos.x, duration, amplitude, period\n"
    "               ),\n"
    "               Ease.Elastic.ease_out(\n"
    "                   elapsed_time, from_pos.t, to_pos.y, duration, amplitude, period\n"
    "               ),\n"
    "           )\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_NETWORK_MODULE =
    "import seika_engine_api\n"
    "\n"
    "\n"
    "class Network:\n"
    "   @staticmethod\n"
    "   def connect_signal(signal_id: str, listener_node, function_name: str) -> None:\n"
    "       seika_engine_api.node_signal_connect(\n"
    "           entity_id=0,\n"
    "           signal_id=signal_id,\n"
    "           listener_entity_id=listener_node.entity_id,\n"
    "           function_name=function_name,\n"
    "       )\n"
    "\n"
    "   @staticmethod\n"
    "   def is_server() -> bool:\n"
    "       return seika_engine_api.network_is_server()\n"
    "\n"
    "\n"
    "class Server:\n"
    "   @staticmethod\n"
    "   def start(port: int) -> None:\n"
    "       seika_engine_api.server_start(port=port)\n"
    "\n"
    "   @staticmethod\n"
    "   def stop() -> None:\n"
    "       seika_engine_api.server_stop()\n"
    "\n"
    "   @staticmethod\n"
    "   def send_message_to_all_clients(message: str) -> None:\n"
    "       seika_engine_api.server_send_message_to_all_clients(message=message)\n"
    "\n"
    "\n"
    "class Client:\n"
    "   @staticmethod\n"
    "   def connect(endpoint: str, port: int) -> None:\n"
    "       seika_engine_api.client_connect(endpoint=endpoint, port=port)\n"
    "\n"
    "   @staticmethod\n"
    "   def disconnect() -> None:\n"
    "       seika_engine_api.client_disconnect()\n"
    "\n"
    "   @staticmethod\n"
    "   def send_message_to_server(message: str) -> None:\n"
    "       seika_engine_api.client_send_message_to_server(message=message)\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_NODE_MODULE =
    "from enum import Enum\n"
    "from typing import Optional, List\n"
    "import seika_engine_api\n"
    "from seika.assets import Texture, AnimationFrame, Animation, Font\n"
    "from seika.math import Vector2, Vector3, Rect2\n"
    "from seika.color import Color\n"
    "\n"
    "\n"
    "class NodeType(str, Enum):\n"
    "   NODE = \"Node\"\n"
    "   TIMER = \"Timer\"\n"
    "   NODE2D = \"Node2D\"\n"
    "   SPRITE = \"Sprite\"\n"
    "   ANIMATED_SPRITE = \"AnimatedSprite\"\n"
    "   TEXT_LABEL = \"TextLabel\"\n"
    "   COLLISION_SHAPE2D = \"CollisionShape2D\"\n"
    "\n"
    "\n"
    "class Node:\n"
    "   def __init__(self, entity_id: int) -> None:\n"
    "       self.entity_id = entity_id\n"
    "\n"
    "   def __eq__(self, other) -> bool:\n"
    "       if self.entity_id == other.entity_id:\n"
    "           return True\n"
    "       else:\n"
    "           return False\n"
    "\n"
    "   @classmethod\n"
    "   def extract_valid_inheritance_node(cls) -> str:\n"
    "       valid_node_type_list = [e.value for e in NodeType]\n"
    "       for class_path in cls.__mro__:\n"
    "           if class_path.__name__ in valid_node_type_list:\n"
    "               return class_path.__name__\n"
    "       return \"\"\n"
    "\n"
    "   @classmethod\n"
    "   def new(cls):\n"
    "       return seika_engine_api.node_new(\n"
    "           class_path=f\"{cls.__module__}\",\n"
    "           class_name=f\"{cls.__name__}\",\n"
    "           node_type=f\"{cls.extract_valid_inheritance_node()}\",\n"
    "       )\n"
    "\n"
    "   @staticmethod\n"
    "   def parse_scene_node_from_engine(scene_node):\n"
    "       if not isinstance(scene_node, tuple):\n"
    "           return scene_node\n"
    "       elif scene_node:\n"
    "           node_type = scene_node[0]\n"
    "           entity_id = scene_node[1]\n"
    "           node_class = globals()[node_type]\n"
    "           instance = node_class(entity_id=entity_id)\n"
    "           return instance\n"
    "       print(\"Error with python api function 'parse_scene_node_from_engine'\")\n"
    "       return None\n"
    "\n"
    "   def add_child(self, child_node) -> None:\n"
    "       seika_engine_api.node_add_child(\n"
    "           parent_entity_id=self.entity_id, child_entity_id=child_node.entity_id\n"
    "       )\n"
    "\n"
    "   def get_node(self, name: str):\n"
    "       node = seika_engine_api.node_get_node(name=name)\n"
    "       if not node:\n"
    "           return None\n"
    "       return self.parse_scene_node_from_engine(scene_node=node)\n"
    "\n"
    "   def queue_deletion(self) -> None:\n"
    "       seika_engine_api.node_queue_deletion(entity_id=self.entity_id)\n"
    "\n"
    "   def create_signal(self, signal_id: str) -> None:\n"
    "       seika_engine_api.node_signal_create(\n"
    "           entity_id=self.entity_id, signal_id=signal_id\n"
    "       )\n"
    "\n"
    "   def connect_signal(self, signal_id: str, listener_node, function_name: str) -> None:\n"
    "       seika_engine_api.node_signal_connect(\n"
    "           entity_id=self.entity_id,\n"
    "           signal_id=signal_id,\n"
    "           listener_entity_id=listener_node.entity_id,\n"
    "           function_name=function_name,\n"
    "       )\n"
    "\n"
    "   def emit_signal(self, signal_id: str, args=[]) -> None:\n"
    "       seika_engine_api.node_signal_emit(\n"
    "           entity_id=self.entity_id, signal_id=signal_id, args=args\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def name(self) -> str:\n"
    "       return seika_engine_api.node_get_name(entity_id=self.entity_id)\n"
    "\n"
    "   @property\n"
    "   def tags(self) -> list:\n"
    "       return seika_engine_api.node_get_tags(entity_id=self.entity_id)\n"
    "\n"
    "   @tags.setter\n"
    "   def tags(self, value: list) -> None:\n"
    "       seika_engine_api.node_set_tags(entity_id=self.entity_id, tags=value)\n"
    "\n"
    "   def show(self) -> None:\n"
    "       seika_engine_api.node_show(entity_id=self.entity_id)\n"
    "\n"
    "   def hide(self) -> None:\n"
    "       seika_engine_api.node_hide(entity_id=self.entity_id)\n"
    "\n"
    "   @property\n"
    "   def visibility(self) -> bool:\n"
    "       return seika_engine_api.node_is_visible(entity_id=self.entity_id)\n"
    "\n"
    "   @visibility.setter\n"
    "   def visibility(self, value: bool) -> None:\n"
    "       if value:\n"
    "           self.show()\n"
    "       else:\n"
    "           self.hide()\n"
    "\n"
    "   def get_parent(self):\n"
    "       parent_node = seika_engine_api.node_get_parent(entity_id=self.entity_id)\n"
    "       if parent_node:\n"
    "           return parent_node\n"
    "       return self.parse_scene_node_from_engine(scene_node=parent_node)\n"
    "\n"
    "   def get_children(self) -> list:\n"
    "       children_nodes = []\n"
    "       children = seika_engine_api.node_get_children(entity_id=self.entity_id)\n"
    "       for child_node in children:\n"
    "           children_nodes.append(\n"
    "               self.parse_scene_node_from_engine(scene_node=child_node)\n"
    "           )\n"
    "       return children_nodes\n"
    "\n"
    "\n"
    "class Timer(Node):\n"
    "   @property\n"
    "   def wait_time(self) -> float:\n"
    "       return seika_engine_api.timer_get_wait_time(entity_id=self.entity_id)\n"
    "\n"
    "   @wait_time.setter\n"
    "   def wait_time(self, value: float) -> None:\n"
    "       seika_engine_api.timer_set_wait_time(entity_id=self.entity_id, wait_time=value)\n"
    "\n"
    "   def get_wait_time(self) -> float:\n"
    "       return seika_engine_api.timer_get_wait_time(entity_id=self.entity_id)\n"
    "\n"
    "   def set_wait_time(self, wait_time: float) -> None:\n"
    "       seika_engine_api.timer_set_wait_time(\n"
    "           entity_id=self.entity_id, wait_time=wait_time\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def time_left(self) -> float:\n"
    "       return seika_engine_api.timer_get_time_left(entity_id=self.entity_id)\n"
    "\n"
    "   def get_time_left(self) -> float:\n"
    "       return seika_engine_api.timer_get_time_left(entity_id=self.entity_id)\n"
    "\n"
    "   @property\n"
    "   def loops(self) -> bool:\n"
    "       return seika_engine_api.timer_get_loops(entity_id=self.entity_id)\n"
    "\n"
    "   @loops.setter\n"
    "   def loops(self, value: bool) -> None:\n"
    "       seika_engine_api.timer_set_loops(entity_id=self.entity_id, loops=value)\n"
    "\n"
    "   def does_loop(self) -> bool:\n"
    "       return seika_engine_api.timer_get_loops(entity_id=self.entity_id)\n"
    "\n"
    "   def set_loop(self, does_loop: bool) -> None:\n"
    "       seika_engine_api.timer_set_loops(entity_id=self.entity_id, loops=does_loop)\n"
    "\n"
    "   def start(self, wait_time: Optional[float] = None) -> None:\n"
    "       if wait_time:\n"
    "           seika_engine_api.timer_set_wait_time(\n"
    "               entity_id=self.entity_id, wait_time=wait_time\n"
    "           )\n"
    "       seika_engine_api.timer_start(entity_id=self.entity_id)\n"
    "\n"
    "   def stop(self) -> None:\n"
    "       seika_engine_api.timer_stop(entity_id=self.entity_id)\n"
    "\n"
    "   @property\n"
    "   def is_stopped(self) -> bool:\n"
    "       return seika_engine_api.timer_is_stopped(entity_id=self.entity_id)\n"
    "\n"
    "   def pause(self) -> None:\n"
    "       seika_engine_api.timer_pause(entity_id=self.entity_id)\n"
    "\n"
    "   def resume(self) -> None:\n"
    "       seika_engine_api.timer_resume(entity_id=self.entity_id)\n"
    "\n"
    "   @property\n"
    "   def is_paused(self) -> bool:\n"
    "       return seika_engine_api.timer_is_paused(entity_id=self.entity_id)\n"
    "\n"
    "\n"
    "# 2D\n"
    "class Node2D(Node):\n"
    "   def set_position(self, value: Vector2) -> None:\n"
    "       seika_engine_api.node2D_set_position(\n"
    "           entity_id=self.entity_id, x=value.x, y=value.y\n"
    "       )\n"
    "\n"
    "   def add_to_position(self, value: Vector2) -> None:\n"
    "       seika_engine_api.node2D_add_to_position(\n"
    "           entity_id=self.entity_id, x=value.x, y=value.y\n"
    "       )\n"
    "\n"
    "   def get_position(self) -> Vector2:\n"
    "       px, py = seika_engine_api.node2D_get_position(entity_id=self.entity_id)\n"
    "       return Vector2(px, py)\n"
    "\n"
    "   @property\n"
    "   def position(self) -> Vector2:\n"
    "       px, py = seika_engine_api.node2D_get_position(entity_id=self.entity_id)\n"
    "       return Vector2(px, py)\n"
    "\n"
    "   @position.setter\n"
    "   def position(self, value: Vector2) -> None:\n"
    "       seika_engine_api.node2D_set_position(\n"
    "           entity_id=self.entity_id, x=value.x, y=value.y\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def rotation(self) -> float:\n"
    "       return seika_engine_api.node2D_get_rotation(entity_id=self.entity_id)\n"
    "\n"
    "   @rotation.setter\n"
    "   def rotation(self, value: float) -> None:\n"
    "       seika_engine_api.node2D_set_rotation(entity_id=self.entity_id, rotation=value)\n"
    "\n"
    "   @property\n"
    "   def z_index(self) -> int:\n"
    "       return seika_engine_api.node2D_get_z_index(entity_id=self.entity_id)\n"
    "\n"
    "   @z_index.setter\n"
    "   def z_index(self, value: int) -> None:\n"
    "       seika_engine_api.node2D_set_z_index(entity_id=self.entity_id, z_index=value)\n"
    "\n"
    "\n"
    "class Sprite(Node2D):\n"
    "   @property\n"
    "   def flip_h(self) -> bool:\n"
    "       return seika_engine_api.sprite_get_flip_h(entity_id=self.entity_id)\n"
    "\n"
    "   @flip_h.setter\n"
    "   def flip_h(self, value: bool) -> None:\n"
    "       seika_engine_api.sprite_set_flip_h(entity_id=self.entity_id, flip_h=value)\n"
    "\n"
    "   @property\n"
    "   def flip_v(self) -> bool:\n"
    "       return seika_engine_api.sprite_get_flip_v(entity_id=self.entity_id)\n"
    "\n"
    "   @flip_v.setter\n"
    "   def flip_v(self, value: bool) -> None:\n"
    "       seika_engine_api.sprite_set_flip_v(entity_id=self.entity_id, flip_h=value)\n"
    "\n"
    "   @property\n"
    "   def modulate(self) -> Color:\n"
    "       red, green, blue, alpha = seika_engine_api.sprite_get_modulate(\n"
    "           entity_id=self.entity_id\n"
    "       )\n"
    "       return Color(r=red, g=green, b=blue, a=alpha)\n"
    "\n"
    "   @modulate.setter\n"
    "   def modulate(self, color: Color) -> None:\n"
    "       seika_engine_api.sprite_set_modulate(\n"
    "           entity_id=self.entity_id,\n"
    "           red=color.r,\n"
    "           green=color.g,\n"
    "           blue=color.b,\n"
    "           alpha=color.a,\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def texture(self) -> Texture:\n"
    "       (\n"
    "           file_path,\n"
    "           wrap_s,\n"
    "           wrap_t,\n"
    "           filter_min,\n"
    "           filter_max,\n"
    "       ) = seika_engine_api.sprite_get_texture(entity_id=self.entity_id)\n"
    "       return Texture(\n"
    "           file_path=file_path,\n"
    "           wrap_s=wrap_s,\n"
    "           wrap_t=wrap_t,\n"
    "           filter_min=filter_min,\n"
    "           filter_max=filter_max,\n"
    "       )\n"
    "\n"
    "   @texture.setter\n"
    "   def texture(self, value: Texture) -> None:\n"
    "       seika_engine_api.sprite_set_texture(\n"
    "           entity_id=self.entity_id, file_path=value.file_path\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def draw_source(self) -> Rect2:\n"
    "       (\n"
    "           x,\n"
    "           y,\n"
    "           w,\n"
    "           h,\n"
    "       ) = seika_engine_api.sprite_get_draw_source(entity_id=self.entity_id)\n"
    "       return Rect2(x=x, y=y, w=w, h=h)\n"
    "\n"
    "   @draw_source.setter\n"
    "   def draw_source(self, value: Rect2) -> None:\n"
    "       seika_engine_api.sprite_set_draw_source(\n"
    "           entity_id=self.entity_id, x=value.x, y=value.y, w=value.w, h=value.h\n"
    "       )\n"
    "\n"
    "\n"
    "class AnimatedSprite(Node2D):\n"
    "   def play(self, animation_name=\"\") -> None:\n"
    "       seika_engine_api.animated_sprite_play(\n"
    "           entity_id=self.entity_id, animation_name=animation_name\n"
    "       )\n"
    "\n"
    "   def set_animation(self, animation_name: str) -> None:\n"
    "       seika_engine_api.animated_sprite_set_animation(\n"
    "           entity_id=self.entity_id, animation_name=animation_name\n"
    "       )\n"
    "\n"
    "   def stop(self) -> None:\n"
    "       seika_engine_api.animated_sprite_stop(entity_id=self.entity_id)\n"
    "\n"
    "   @property\n"
    "   def current_animation(self) -> Animation:\n"
    "       return Animation(name=\"\", speed=200, frames=[])\n"
    "\n"
    "   @current_animation.setter\n"
    "   def current_animation(self, value: Animation) -> None:\n"
    "       seika_engine_api.animated_sprite_set_animation(\n"
    "           entity_id=self.entity_id, animation_name=value.name\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def animations(self) -> List[Animation]:\n"
    "       # def get_mock_animations() -> list:\n"
    "       #     mock_animations = [\n"
    "       #         [\n"
    "       #             (\n"
    "       #                 # Animation Name\n"
    "       #                 \"idle\",\n"
    "       #                 # Animation Speed\n"
    "       #                 200,\n"
    "       #                 # Animation Frames\n"
    "       #                 [\n"
    "       #                     (\n"
    "       #                         # Texture Path\n"
    "       #                         \"assets/images/mock.png\",\n"
    "       #                         # Draw Source\n"
    "       #                         0,\n"
    "       #                         0,\n"
    "       #                         16,\n"
    "       #                         16,\n"
    "       #                         # index\n"
    "       #                         0,\n"
    "       #                     )\n"
    "       #                 ],\n"
    "       #             )\n"
    "       #         ]\n"
    "       #     ]\n"
    "       #     return mock_animations\n"
    "\n"
    "       received_animations = []\n"
    "       for (\n"
    "           anim_name,\n"
    "           anim_speed,\n"
    "           anim_frames,\n"
    "       ) in seika_engine_api.animates_sprite_get_animations(entity_id=self.entity_id):\n"
    "           in_anim_frames = []\n"
    "           for frame_texture_path, x, y, w, h, frame_index in anim_frames:\n"
    "               frame_draw_source = Rect2(x, y, w, h)\n"
    "               in_anim_frames.append(\n"
    "                   AnimationFrame(\n"
    "                       texture=Texture.get(frame_texture_path),\n"
    "                       draw_source=frame_draw_source,\n"
    "                       index=frame_index,\n"
    "                   )\n"
    "               )\n"
    "           received_animations.append(\n"
    "               Animation(name=anim_name, speed=anim_speed, frames=in_anim_frames)\n"
    "           )\n"
    "\n"
    "       return received_animations\n"
    "\n"
    "   @animations.setter\n"
    "   def animations(self, value: List[Animation]) -> None:\n"
    "       new_anims = []\n"
    "       for anim in value:\n"
    "           anim_frames = []\n"
    "           for anim_frame in anim.frames:\n"
    "               anim_frames.append(\n"
    "                   (\n"
    "                       anim_frame.texture.file_path,\n"
    "                       anim_frame.draw_source.x,\n"
    "                       anim_frame.draw_source.y,\n"
    "                       anim_frame.draw_source.w,\n"
    "                       anim_frame.draw_source.h,\n"
    "                       anim_frame.index,\n"
    "                   )\n"
    "               )\n"
    "           new_anims.append((anim.name, anim.speed, anim_frames))\n"
    "       seika_engine_api.animated_sprite_set_animations(\n"
    "           entity_id=self.entity_id, animations=new_anims\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def is_playing(self) -> bool:\n"
    "       return seika_engine_api.animated_is_playing(entity_id=self.entity_id)\n"
    "\n"
    "   @property\n"
    "   def modulate(self) -> Color:\n"
    "       red, green, blue, alpha = seika_engine_api.animated_sprite_get_modulate(\n"
    "           entity_id=self.entity_id\n"
    "       )\n"
    "       return Color(r=red, g=green, b=blue, a=alpha)\n"
    "\n"
    "   @modulate.setter\n"
    "   def modulate(self, color: Color) -> None:\n"
    "       seika_engine_api.animated_sprite_set_modulate(\n"
    "           entity_id=self.entity_id,\n"
    "           red=color.r,\n"
    "           green=color.g,\n"
    "           blue=color.b,\n"
    "           alpha=color.a,\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def frame(self) -> int:\n"
    "       return seika_engine_api.animated_sprite_get_frame(entity_id=self.entity_id)\n"
    "\n"
    "   @frame.setter\n"
    "   def frame(self, value: int) -> None:\n"
    "       seika_engine_api.animated_sprite_set_frame(\n"
    "           entity_id=self.entity_id, frame=value\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def animation_frames(self) -> int:\n"
    "       return seika_engine_api.animated_sprite_get_animation_frames(\n"
    "           entity_id=self.entity_id\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def animation_speed(self) -> int:\n"
    "       return seika_engine_api.animated_sprite_get_animation_speed(\n"
    "           entity_id=self.entity_id\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def flip_h(self) -> bool:\n"
    "       return seika_engine_api.animated_sprite_get_flip_h(entity_id=self.entity_id)\n"
    "\n"
    "   @flip_h.setter\n"
    "   def flip_h(self, value: bool) -> None:\n"
    "       seika_engine_api.animated_sprite_set_flip_h(\n"
    "           entity_id=self.entity_id, flip_h=value\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def flip_v(self) -> bool:\n"
    "       return seika_engine_api.animated_sprite_get_flip_v(entity_id=self.entity_id)\n"
    "\n"
    "   @flip_v.setter\n"
    "   def flip_v(self, value: bool) -> None:\n"
    "       seika_engine_api.animated_sprite_set_flip_v(\n"
    "           entity_id=self.entity_id, flip_h=value\n"
    "       )\n"
    "\n"
    "\n"
    "class TextLabel(Node2D):\n"
    "   @property\n"
    "   def text(self) -> str:\n"
    "       return seika_engine_api.text_label_get_text(entity_id=self.entity_id)\n"
    "\n"
    "   @text.setter\n"
    "   def text(self, value: str) -> None:\n"
    "       seika_engine_api.text_label_set_text(entity_id=self.entity_id, text=value)\n"
    "\n"
    "   def get_text(self) -> str:\n"
    "       return seika_engine_api.text_label_get_text(entity_id=self.entity_id)\n"
    "\n"
    "   def set_text(self, text: str) -> None:\n"
    "       seika_engine_api.text_label_set_text(entity_id=self.entity_id, text=text)\n"
    "\n"
    "   @property\n"
    "   def color(self) -> Color:\n"
    "       red, green, blue, alpha = seika_engine_api.text_label_get_color(\n"
    "           entity_id=self.entity_id\n"
    "       )\n"
    "       return Color(r=red, g=green, b=blue, a=alpha)\n"
    "\n"
    "   @color.setter\n"
    "   def color(self, value: Color) -> None:\n"
    "       seika_engine_api.text_label_set_color(\n"
    "           entity_id=self.entity_id,\n"
    "           red=value.r,\n"
    "           green=value.g,\n"
    "           blue=value.b,\n"
    "           alpha=value.a,\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def font(self) -> Font:\n"
    "       uid, file_path, size = seika_engine_api.text_label_get_font(\n"
    "           entity_id=self.entity_id\n"
    "       )\n"
    "       return Font(uid=uid, file_path=file_path, size=size)\n"
    "\n"
    "   @font.setter\n"
    "   def font(self, value: Font) -> None:\n"
    "       seika_engine_api.text_label_set_font(entity_id=self.entity_id, uid=value.uid)\n"
    "\n"
    "   @property\n"
    "   def word_wrap(self) -> bool:\n"
    "       return seika_engine_api.text_label_get_word_wrap(entity_id=self.entity_id)\n"
    "\n"
    "   @word_wrap.setter\n"
    "   def word_wrap(self, value: bool) -> None:\n"
    "       seika_engine_api.text_label_set_word_wrap(\n"
    "           entity_id=self.entity_id, word_wrap=value\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def max_characters_per_line(self) -> int:\n"
    "       return seika_engine_api.text_label_get_max_characters_per_line(\n"
    "           entity_id=self.entity_id\n"
    "       )\n"
    "\n"
    "   @max_characters_per_line.setter\n"
    "   def max_characters_per_line(self, value: int) -> None:\n"
    "       seika_engine_api.text_label_set_max_characters_per_line(\n"
    "           entity_id=self.entity_id, max_characters=value\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def new_line_padding(self) -> int:\n"
    "       return seika_engine_api.text_label_get_new_line_padding(\n"
    "           entity_id=self.entity_id\n"
    "       )\n"
    "\n"
    "   @new_line_padding.setter\n"
    "   def new_line_padding(self, value: int) -> None:\n"
    "       seika_engine_api.text_label_set_new_line_padding(\n"
    "           entity_id=self.entity_id, new_line_padding=value\n"
    "       )\n"
    "\n"
    "\n"
    "class CollisionShape2D(Node2D):\n"
    "   @property\n"
    "   def collider_rect(self) -> Rect2:\n"
    "       x, y, w, h = seika_engine_api.collision_shape2d_get_collider_rect(\n"
    "           entity_id=self.entity_id\n"
    "       )\n"
    "       return Rect2(x=x, y=y, w=w, h=h)\n"
    "\n"
    "   @collider_rect.setter\n"
    "   def collider_rect(self, value: Rect2) -> None:\n"
    "       seika_engine_api.collision_shape2d_set_collider_rect(\n"
    "           entity_id=self.entity_id, x=value.x, y=value.y, w=value.w, h=value.h\n"
    "       )\n"
    "\n"
    "   def add_collision_exception(self, node) -> None:\n"
    "       seika_engine_api.collision_shape2d_add_collision_exception(\n"
    "           entity_id=self.entity_id, exception_entity_id=node.entity_id\n"
    "       )\n"
    "\n"
    "   def remove_collision_exception(self, node) -> None:\n"
    "       seika_engine_api.collision_shape2d_remove_collision_exception(\n"
    "           entity_id=self.entity_id, exception_entity_id=node.entity_id\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def color(self) -> Color:\n"
    "       red, green, blue, alpha = seika_engine_api.collision_shape2d_get_color(\n"
    "           entity_id=self.entity_id\n"
    "       )\n"
    "       return Color(r=red, g=green, b=blue, a=alpha)\n"
    "\n"
    "   @color.setter\n"
    "   def color(self, value: Color) -> None:\n"
    "       seika_engine_api.collision_shape2d_set_color(\n"
    "           entity_id=self.entity_id,\n"
    "           red=value.r,\n"
    "           green=value.g,\n"
    "           blue=value.b,\n"
    "           alpha=value.a,\n"
    "       )\n"
    "\n"
    "   @property\n"
    "   def is_under_mouse(self) -> bool:\n"
    "       return seika_engine_api.collision_shape2d_is_under_mouse(\n"
    "           entity_id=self.entity_id\n"
    "       )\n"
    "\n"
    "\n"
    "# 3D\n"
    "class Spatial(Node):\n"
    "   def set_position(self, value: Vector3) -> None:\n"
    "       pass\n"
    "\n"
    "   def add_to_position(self, value: Vector3) -> None:\n"
    "       pass\n"
    "\n"
    "   def get_position(self) -> Vector3:\n"
    "       return Vector3()\n"
    "\n"
    "   @property\n"
    "   def position(self) -> Vector3:\n"
    "       return Vector3()\n"
    "\n"
    "   @position.setter\n"
    "   def position(self, value: Vector3) -> None:\n"
    "       pass\n"
    "\n"
    "\n"
    "class TextureCube(Spatial):\n"
    "   pass\n"
    "\n"
    "\n"
    "class DirectionalLight(Spatial):\n"
    "   @property\n"
    "   def direction(self) -> Vector3:\n"
    "       return Vector3()\n"
    "\n"
    "   @direction.setter\n"
    "   def direction(self, value: Vector3) -> None:\n"
    "       pass\n"
    "\n"
    "\n"
    "class PointLight(Spatial):\n"
    "   @property\n"
    "   def cutoff(self) -> float:\n"
    "       return 0.0\n"
    "\n"
    "   @cutoff.setter\n"
    "   def cutoff(self, value: float) -> None:\n"
    "       pass\n"
    "\n"
    "   @property\n"
    "   def outer_cutoff(self) -> float:\n"
    "       return 0.0\n"
    "\n"
    "   @outer_cutoff.setter\n"
    "   def outer_cutoff(self, value: float) -> None:\n"
    "       pass\n"
    "\n"
    "\n"
    "class SpotLight(Spatial):\n"
    "   @property\n"
    "   def direction(self) -> Vector3:\n"
    "       return Vector3()\n"
    "\n"
    "   @direction.setter\n"
    "   def direction(self, value: Vector3) -> None:\n"
    "       pass\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_PHYSICS_MODULE =
    "import seika_engine_api\n"
    "from seika.math import Vector2\n"
    "from seika.node import Node\n"
    "\n"
    "\n"
    "class Collision:\n"
    "   @staticmethod\n"
    "   def get_collided_nodes(node: Node, offset=Vector2(0, 0)) -> list:\n"
    "       seika_engine_api.collision_update_collisions(\n"
    "           entity_id=node.entity_id, offset_x=offset.x, offset_y=offset.y\n"
    "       )\n"
    "       collided_nodes_from_engine = seika_engine_api.collision_get_collided_nodes(\n"
    "           entity_id=node.entity_id\n"
    "       )\n"
    "       collided_nodes = []\n"
    "       for collided_node in collided_nodes_from_engine:\n"
    "           collided_nodes.append(\n"
    "               Node.parse_scene_node_from_engine(scene_node=collided_node)\n"
    "           )\n"
    "       return collided_nodes\n"
    "\n"
    "   @staticmethod\n"
    "   def get_collided_nodes_by_tag(node: Node, tag: str, offset=Vector2(0, 0)) -> list:\n"
    "       collided_nodes_from_engine = (\n"
    "           seika_engine_api.collision_get_collided_nodes_by_tag(\n"
    "               entity_id=node.entity_id, tag=tag, offset_x=offset.x, offset_y=offset.y\n"
    "           )\n"
    "       )\n"
    "       collided_nodes = []\n"
    "       for collided_node in collided_nodes_from_engine:\n"
    "           collided_nodes.append(\n"
    "               Node.parse_scene_node_from_engine(scene_node=collided_node)\n"
    "           )\n"
    "       return collided_nodes\n"
    "\n"
    "   @staticmethod\n"
    "   def get_nodes_under_mouse() -> list:\n"
    "       collided_nodes = []\n"
    "       collided_nodes_from_engine = seika_engine_api.collision_get_nodes_under_mouse()\n"
    "       for node in collided_nodes_from_engine:\n"
    "           collided_nodes.append(Node.parse_scene_node_from_engine(scene_node=node))\n"
    "       return collided_nodes\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_RENDERER_MODULE =
    "import seika_engine_api\n"
    "from seika.math import Rect2\n"
    "from seika.color import Color\n"
    "\n"
    "\n"
    "class Renderer:\n"
    "   @staticmethod\n"
    "   def draw_texture(\n"
    "       texture_path: str,\n"
    "       source_rect: Rect2,\n"
    "       dest_rect: Rect2,\n"
    "       z_index=0,\n"
    "       rotation=0.0,\n"
    "       color=Color(1.0, 1.0, 1.0, 1.0),\n"
    "       flip_x=False,\n"
    "       flip_y=False,\n"
    "   ) -> None:\n"
    "       seika_engine_api.renderer_draw_texture(\n"
    "           texture_path=texture_path,\n"
    "           source_rect_x=source_rect.x,\n"
    "           source_rect_y=source_rect.y,\n"
    "           source_rect_w=source_rect.w,\n"
    "           source_rect_h=source_rect.h,\n"
    "           dest_rect_x=dest_rect.x,\n"
    "           dest_rect_y=dest_rect.y,\n"
    "           dest_rect_w=dest_rect.w,\n"
    "           dest_rect_h=dest_rect.h,\n"
    "           z_index=z_index,\n"
    "           rotation=rotation,\n"
    "           color_red=color.r,\n"
    "           color_green=color.g,\n"
    "           color_blue=color.b,\n"
    "           color_alpha=color.a,\n"
    "           flip_x=flip_x,\n"
    "           flip_y=flip_y,\n"
    "       )\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_SCENE_MODULE =
    "import seika_engine_api\n"
    "from seika.node import Node, Node2D, Sprite, AnimatedSprite, TextLabel\n"
    "\n"
    "\n"
    "class SceneTree:\n"
    "   @staticmethod\n"
    "   def change_scene(scene_path: str) -> None:\n"
    "       seika_engine_api.scene_tree_change_scene(scene_path=scene_path)\n"
    "\n"
    "   @staticmethod\n"
    "   def get_current_scene_node() -> Node:\n"
    "       current_scene_node = seika_engine_api.scene_tree_get_current_scene_node()\n"
    "       return Node.parse_scene_node_from_engine(scene_node=current_scene_node)\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_UTILS_MODULE =
    "class SimpleTimer:\n"
    "   def __init__(\n"
    "       self, wait_time: float, loops=False, timeout_func=None, start_on_init=False\n"
    "   ):\n"
    "       self.wait_time = wait_time\n"
    "       self.loops = loops\n"
    "       self.timeout_func = timeout_func\n"
    "       self.time_left = 0.0\n"
    "       self.running = False\n"
    "       if start_on_init:\n"
    "           self.start()\n"
    "\n"
    "   def start(self) -> None:\n"
    "       self.time_left = self.wait_time\n"
    "       self.running = True\n"
    "\n"
    "   def stop(self) -> None:\n"
    "       self.time_left = 0.0\n"
    "       self.running = False\n"
    "\n"
    "   def tick(self, delta: float) -> bool:\n"
    "       has_timed_out = False\n"
    "       if self.time_left > 0.0 and self.running:\n"
    "           self.time_left -= delta\n"
    "           if self.time_left <= 0.0:\n"
    "               self.stop()\n"
    "               if self.timeout_func:\n"
    "                   self.timeout_func()\n"
    "               has_timed_out = True\n"
    "               if self.loops:\n"
    "                   self.start()\n"
    "       return has_timed_out\n"
    "\n"
    "";



static PythonSource PYTHON_SOURCE_LOAD_SOURCE_IMPORTER_SNIPPET =
    "import sys\n"
    "import importlib\n"
    "import importlib.util\n"
    "\n"
    "module_name = \"source_importer\"\n"
    "source_code = \"\"\"\n"
    "import sys\n"
    "import importlib\n"
    "import importlib.util\n"
    "\n"
    "class SourceImporter:\n"
    "   def __init__(self, modules: dict):\n"
    "       self._modules = modules\n"
    "\n"
    "       for module_name in self._modules:\n"
    "           module_src = self._modules[module_name]\n"
    "           self.import_from_source(module_name, module_src)\n"
    "\n"
    "   def import_from_source(self, module_name: str, source_code: str):\n"
    "       spec = importlib.util.spec_from_loader(module_name, loader=None, is_package=False)\n"
    "       module = importlib.util.module_from_spec(spec)\n"
    "       exec(source_code, module.__dict__)\n"
    "       sys.modules[module_name] = module\n"
    "       return module\n"
    "\"\"\"\n"
    "\n"
    "# Load source importer module\n"
    "spec = importlib.util.spec_from_loader(module_name, loader=None, is_package=False)\n"
    "module = importlib.util.module_from_spec(spec)\n"
    "exec(source_code, module.__dict__)\n"
    "sys.modules[module_name] = module\n"
    "\n"
    "";

static PythonSource PYTHON_SOURCE_IMPORT_ENGINE_MODULE_SNIPPET =
    "from source_importer import SourceImporter\n"
    "\n"
    "modules_to_import = {\n"


    "\"seika.engine\": \"\"\"\n"
    + PYTHON_SOURCE_ENGINE_MODULE +
    "\"\"\",\n"


    "\"seika.audio\": \"\"\"\n"
    + PYTHON_SOURCE_AUDIO_MODULE +
    "\"\"\",\n"


    "\"seika.math\": \"\"\"\n"
    + PYTHON_SOURCE_MATH_MODULE +
    "\"\"\",\n"


    "\"seika.color\": \"\"\"\n"
    + PYTHON_SOURCE_COLOR_MODULE +
    "\"\"\",\n"


    "\"seika.input\": \"\"\"\n"
    + PYTHON_SOURCE_INPUT_MODULE +
    "\"\"\",\n"


    "\"seika.camera\": \"\"\"\n"
    + PYTHON_SOURCE_CAMERA_MODULE +
    "\"\"\",\n"


    "\"seika.assets\": \"\"\"\n"
    + PYTHON_SOURCE_ASSETS_MODULE +
    "\"\"\",\n"


    "\"seika.node\": \"\"\"\n"
    + PYTHON_SOURCE_NODE_MODULE +
    "\"\"\",\n"


    "\"seika.physics\": \"\"\"\n"
    + PYTHON_SOURCE_PHYSICS_MODULE +
    "\"\"\",\n"


    "\"seika.scene\": \"\"\"\n"
    + PYTHON_SOURCE_SCENE_MODULE +
    "\"\"\",\n"


    "\"seika.network\": \"\"\"\n"
    + PYTHON_SOURCE_NETWORK_MODULE +
    "\"\"\",\n"


    "\"seika.renderer\": \"\"\"\n"
    + PYTHON_SOURCE_RENDERER_MODULE +
    "\"\"\",\n"


    "\"seika.data\": \"\"\"\n"
    + PYTHON_SOURCE_DATA_MODULE +
    "\"\"\",\n"


    "\"seika.utils\": \"\"\"\n"
    + PYTHON_SOURCE_UTILS_MODULE +
    "\"\"\",\n"



    "}\n"
    "\n"
    "game_source_importer = SourceImporter(modules=modules_to_import)\n"
    "\n"
    "";

#endif //PYTHON_SOURCE_H
